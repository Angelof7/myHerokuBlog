
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>斯坦福大学iOS7学习笔记 - VongLo's Dev Space</title>
	<meta name="author" content="VongLo">

	
	<meta name="description" content="斯坦福iOS7学习笔记">
	<meta name="keywords" content="斯坦福、iOS7">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="360-site-verification" content="71c95173e5269a4d306def7ed27f2a48" />
	<meta name="baidu-site-verification" content="GXlqZbIq3a" />
	<link href="/atom.xml" rel="alternate" title="VongLo's Dev Space" type="application/atom+xml">
	
	<link rel="canonical" href="http://wang9262.github.io/blog/2014/03/01/stanford-ios7-learning/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<script type="text/javascript">

function addBlankTargetForLinks () {

  $('a[href^="http"]').each(function(){

      $(this).attr('target', '_blank');

  });

}

$(document).bind('DOMNodeInserted', function(event) {

  addBlankTargetForLinks();

});

</script>

	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='/images/tx.png' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">VongLo's Dev Space</a></h1>
<p class="subtitle">寥寥浮生二十载,不求闻达<br>默默无闻，只求无愧于心</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="/about">关于我</a></li>
</ul>


<section class="aboutme">
  <p>
    What makes you silent makes you silent.
  </p>
</section>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/3129068073" title="Weibo">Weibo</a>
		
		
		
		
		
		<a class="github" href="https://github.com/wang9262" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">斯坦福大学iOS7学习笔记</h1>
	<div class="entry-content" itemprop="articleBody"><p>其实这个视频出来也有一段时间了，但是由于各种原因一直拖到现在还没看完。这篇文章是我在观看视频以及自己Demo时的一些笔记记录,有些可能上下文不连贯,如果造成不便请理解,也可以留言指出。</p>

<!--more-->


<p>
<img src="/images/blogimg/stanford/description.png" alt="" /></p>

<ol>
<li><a href="#1">概览</a></li>
<li><a href="#2">objective-c</a></li>
<li><a href="#3">Foundation And Attributed Strings</a></li>
<li><a href="#4">View Controller Lifecycle</a></li>
<li><a href="#5">Polymorphism with Controllers, UI</a></li>
<li><a href="#6">手势、UIView、CoreGraphics</a></li>
<li><a href="#7">OC的一些语法特色&amp;Animation</a></li>
<li><a href="#8">AutoLayout</a></li>
<li><a href="#9">Multithreading、UIScrollingView、UITableView</a></li>
<li><a href="#10">UITableView</a></li>
<li><a href="#11">Document&amp;Core Data</a></li>
<li><a href="#12">Core Data and Table View</a></li>
<li><a href="#13">其他</a></li>
</ol>


<h1><a id="1"></a>1.概览(第一二集)</h1>

<hr />

<p>IBAction其实就是void</p>

<h1><a id="2"></a>2.objective-c</h1>

<hr />

<p>1.在数组中做插入时，应该先判断插入的位置是否越界。给数组发消息时，最好先判断数组是否为空</p>

<p>2.做输出口连接时，选择<code>Outlet Collection</code>(有三种:Outlet,Action,Outlet Collection)，默认为strong也必须为strong，view对每个输出口都有强引用，但是不会对输出口数组有强引用.当连接时，自动生成。如下图</p>

<p>  <img src="/images/blogimg/stanford/collection.png" alt="" /></p>

<p>如果设置为weak的话，将没有人对其有强引用，数组会持续为空。检查所有的输出口是否全部连接上，可以将鼠标放在property的前面实心圆点上，来观察所有的是否高亮。其中数组中的顺序是未知的</p>

<p>3.当要获取操作的对象在<code>collection</code>中的位置时，可以使用<code>[self.array indexOfObject:sender]</code>;<code>array</code>为<code>collection</code>生成的数组</p>

<p>4.<code>[array firstObject]</code>意义并不等同于 <code>array[0]</code>,当array为nil时，若用array[0]则会导致程序崩溃，而firstObject 则不会（此时return nil即返回nil）。</p>

<h1><a id="3"></a>3.Foundation And Attributed Strings</h1>

<hr />

<p>1.如果给NSString *str 发送[str mutable copy]将会产生一个可变的mutable String。</p>

<p>2.像firstObject、lastObject这种并没有产生新的对象，而是给你一个指向他们的指针。</p>

<p>3.给nil发送消息，将不会崩溃，相应得代码也不会被执行，如果该方法有返回值，则返回0或者nil.但是当返回值是C语言的结构体的话，将返回一个不确定的值，比如CGPoint p = [nil getLoction],此时p将是不确定的值。</p>

<p>4.动态绑定，id类型本身就是指针，所以不用加星号，指向一个不确定类型的对象。</p>

<p><img src="/images/blogimg/stanford/objec-pointer.png" alt="" /></p>

<p>运行时所有的对象指针均被当作id来对待。但是在编译时，如果你用比如NSString *而不是id，编译器会给你相应的提示，它可以帮你找出bug，给出适当的方法.</p>

<p>5.由于我们使用的是静态类型定义语言，并且编译器知道你的指针指向的类型.所以，动态绑定相对来说是安全的.但实际上还是有隐患的，比如：</p>

<p><img src="/images/blogimg/stanford/static.png" alt="" /></p>

<p>6.不要使用id *，因为这是指向指针的指针</p>

<p>7.些情况下，编译时会给出警告，而运行时不会崩溃，比如：</p>

<p><img src="/images/blogimg/stanford/warning.png" alt="" /></p>

<p>8.那么什么时候该用到id(动态绑定)呢？</p>

<p><img src="/images/blogimg/stanford/when-to-dynamic.png" alt="" /></p>

<p>要让他变得安全可以使用两种方式：内省（introspection）[即在运行时判断某个对象属于哪个类或者能给它发送什么样的消息]和协议（protocol）</p>

<p>9.所有继承自NSObject的类都有下面的方法</p>

<pre><code>isKindOfClass：某对象是否属于某个(包括继承)
isMemberOfClass：某对象是否属于某个类，(不包括继承)
respondsToSelector:某对象是否相应某个方法
</code></pre>

<p>上面三个方法都是在运行时来确定的。
一般的书写格式：</p>

<p><img src="/images/blogimg/stanford/run-timemodel.png" alt="" /></p>

<p>在数组中可以使用 makeObjectsPerformSelector使数组每个值都执行某个方法。</p>

<h4>Foundation Framework</h4>

<p>1.给可变的对象发送copy消息，返回的是不可变的对象。比如 *arr = [array copy]假设array为可变的。copy消息返回的不可变的，mutableCopy返回的是可变的(不管是给可变或者不可变的对象发送消息都是如此)
2.NSArray一些有意思的方法</p>

<p>  <img src="/images/blogimg/stanford/funnuy-NSArray.png" alt="" /></p>

<p>3.NSNumber的新语法</p>

<p>  <img src="/images/blogimg/stanford/NSNumber-new-syntax.png" alt="" /></p>

<p>4.NSDictionary（类似哈希表）</p>

<p>  <img src="/images/blogimg/stanford/NSDictionary.png" alt="" /></p>

<p>5.Property List （集合的集合） ：NSUserDefaults 就是一个典型的property list ，NSUserDefaults 通常只用来存储一些较小的东西，比如账号、密码最好别用来存储一些容量很大的东西，比如图片，NSData</p>

<p>6.在调用[[NSUserDefaults  standard]setobject:forKey]之后必须使用[[NSUserDefaults  standard] synchronize]是数据同步</p>

<p>7.NSRange   range = （i，j）它的范围是从第i个到i+j-1个。</p>

<p>  <img src="/images/blogimg/stanford/NSRange.png" alt="" /></p>

<p>8.UIColor：alpha（透明度，0代表全透明，1代表不透明）</p>

<p>9.UIFonts ：ios7种很大的一点改进就是对字体的支持更多元化</p>

<p>  <img src="/images/blogimg/stanford/UIFont.png" alt="" /></p>

<p>Attributed Strings</p>

<ol>
<li> NSAttributedString（类似NSString但是字符串中的每个字符都有自己的属性  并非NSString的子类）是不可变的（immutable）</li>
<li>  NSMutableAttributedString（使用的更多）</li>
<li> 所有的属性添加下划线</li>
</ol>


<p>  <img src="/images/blogimg/stanford/underline.png" alt="" /></p>

<h1><a id="4"></a>4.View Controller Lifecycle</h1>

<hr />

<h4>UITextView</h4>

<p>常用属性：
<code>UIFont *font，NSTextStorage *textStorage``NSTextStorage</code>是<code>NSMutableAttributedString</code>的子类，可以随意修改它，UITextView会自动更新修改后的内容。
在设置font的时候最好是为特定的字符或字符串设置font，不然会影响到性能.</p>

<h4>UIView LifeCycle</h4>

<p>不要在viewdidload方法里面设置一些尺寸会发生变化的控件</p>

<p>顺序
awakeFromNib->viewDidload->viewWillLayoutSubviews->viewDidiLayoutSubviews->viewWillAppear->viewDidAppear</p>

<p>1.viewwillappear只需一次性初始化的不要放在该方法中,最好放入viewdidiload.当展示的东西会发生改变时,可以将其放在该方法中,使其同步
一些网络延时等待可以放在这个方法中进而优化,减少等待时间.在该方法中来设置控件尺寸
viewwilldisappear 这个方法一般用来存储当前数据,用作恢复时的重载.</p>

<p>2.viewWill(did)LayoutSubviews (iOS6.0)最好在did里面来改变尺寸</p>

<p>3.awakeFromNib(storyboard)   在输出口被设置之前调用</p>

<p>想要了解更多情况可以看看<a href="http://blog.csdn.net/u012971918/article/details/16983499">理一理UIViewController的东东</a>。</p>

<h4>Notification</h4>

<p>在接收通知后如无需再监听,就<code>removeObeserver:self</code>，<code>viewWillAppear</code>里面添加通知监听同时执行监听到通知后应该执行的方法，在<code>viewWillDisappear</code>里面移除监听。</p>

<p><code>notification center</code>拥有一个<code>unsafe retained</code>指针指向监听者。<code>unsafe retained</code> 意味着如果将监听者移除堆栈却没有调用<code>remove</code>这个方法，<code>notification center</code>仍会向监听者发送notification，这个时候APP将会崩溃。之所以用<code>unsafe retained</code>是因为向前（ios 4、5）兼容的问题。</p>

<h1><a id="5"></a>5.Polymorphism with Controllers, UI</h1>

<hr />

<p>抽象类意味着该类不能被实例化，只能作为超类来给其他具体类来继承。在storyboard里面<code>ctrl+shift+单击</code>，会显示鼠标所在区域的所有东西。</p>

<p>具体类继承了抽象类的outlet以及Action（即使是private也能继承）</p>

<p>导航条上的button并非UIButton而是<code>UIBarButtonItems</code>（轻量级button）放置在<code>NavigationItem</code>上</p>

<p>下方为<code>toolbaritems</code></p>

<h4>segues</h4>

<p>要为每一个segue设置id以便辨识区分</p>

<h4>UINavigationController</h4>

<p>通过self.navigationcontroller来判断当前controller是否为UINavigationController。tabarcontroller同理</p>

<p>判断某个view是否为当前显示，可以用[view.window]是否为nil来判断。当某个view当前并没有显示，但是由于数据变化需要更新其UI，则可将UI更新代码放在viewWillAppear里。UI更新最好作为一个方法updateUI，以方便复用。</p>

<h4>UITabarController</h4>

<p>tabaritem的icon是30*30</p>

<h1><a id="6"></a>6.手势、UIView、CoreGraphics</h1>

<hr />

<h4>UIWindow</h4>

<p>view层级的顶层view，一般情况下一个APP只有一个UIWindow</p>

<p><code>initWithFrame</code>不能用于storyboard的view，可以用<code>awakeFromNib</code></p>

<h4>View的坐标系</h4>

<p>CGFloat:(x,y),CGSize:(width,height),CGRect:(CGFloat,CGSize)</p>

<p>bounds是自身坐标系，frame是父视图坐标系。</p>

<p>可在<code>drawRect</code>方法中对View进行自定义draw。不要调用drawRect，它是供系统调用的，但是可以复写。可以通过调用<code>setneedsdisplay</code>或者<code>setneedsdisplayinrect</code>，这两个方法会调用<code>drawrect</code>方法。</p>

<p>CoreGraphics利用UIBezierPath来完成画线 填色 线条粗细等操作</p>

<p>上下文<code>context</code>决定了画的位置,UIBezierPath在当前上下文<code>context</code>中画因此可以不用去得到上下文.如果要得到上下文可调用<code>CGContextRef context = UIGraphicsGetCurrentContext()</code>,这里直接调用了C函数.<code>CGContextRef</code>是一个void型指针.</p>

<h4>示例</h4>

<pre><code>//用UIBezierPath画三角形
UIBezierPath *path = [[UIBezierPath alloc]init];
[path moveToPoint:CGPointMake(75,10)];
[path addLineToPoint:CGPointMake(160,150)];
[path addLineToPoint:CGPointMake(10,150)];
[path closePath];
path.lineWidth = 3.0f;
//上面所有步骤并没有画出该三角形,仅仅是确定其大小
//需要加上以下几个方法调用才行
[[UIColor redColor]setFill];
[[UIColor blueColor]setStroke];
[path fill];
[path stroke];
</code></pre>

<p>还可以用贝塞尔曲线画各种形状,方法参见API.<code>[path addClip]</code>方法可以剪切出该封闭曲线内所画的内容.</p>

<p>如果要使view有透明度,首先需要将其opaque<code>@property BOOL opaque</code>属性设置为NO(但是对系统性能有一定影响).可以通过设置透明度<code>alpha</code>来改变整个view的透明度.</p>

<p>通过CGContext函数来生成图片</p>

<pre><code>UIGraphicsBeginImageContext(CGSize);
UIImage *image = UIGraphicsGetImageFromCurrentContext();
UIGraphicsEndInamgeContext();
</code></pre>

<p>在UIImage上作图</p>

<pre><code>[img drawAtPoint:point];
[img drawInRect:rect];
[img drawAsPatternInRect:rect];
</code></pre>

<h4>手势</h4>

<p>首先要使view添加手势才能识别,其次要实现手势识别的方法.</p>

<ul>
<li>UITapGestureRecognizer</li>
<li>UIPinchGestureRecognizer</li>
<li>UIRotationGestureRecognizer</li>
<li>UISwipeGestureRecognizer</li>
<li>UIPanGestureRecognizer //缓慢拖动</li>
<li>UILongPressGestureRecognizer</li>
</ul>


<h4>Demo</h4>

<p>NSParaGraphStyle来设置段落的一些属性.</p>

<p>字体的翻转
<code>CGContextTranslateCTM(context,x,y)</code>(x,y是要移动的距离,相对于当前坐标系)来移动,然后在设定角度来翻转即可<code>CGContextRotateCTM(context,M_PI)</code>.</p>

<h1><a id="7"></a>7.OC的一些语法特色&amp;Animation</h1>

<hr />

<h4>协议(Protocol)</h4>

<p>内省:有时有效,但不是主要编程方法,它是在运行时发生的.</p>

<p>Attention!在协议中也可以有属性(property)的申明.</p>

<p><em>NSObject Protocol</em>里面的方法和<em>NSObject</em>种方法是一样的,那为什么要有<em>NSObject protoclo</em>呢?这是作为给那些非<em>NSObject</em>的类在运行时来实现自省.(可以自定义某个类并非继承自NSobjec.如<code>@inteface MyObject</code>,并没有父类,但是经常不这么做,通常所有类都继承自<em>NSObject</em>).</p>

<h4>闭包(Block、closure)</h4>

<p>通常为 <code>^ int (int a,int b)</code>,^为block标识符,紧接着为返回类型,然后是变量.如果可以从其返回值推测其返回类型,可以省去返回值.(如省去int)</p>

<p>对于闭包外的局部变量,在闭包内使用时是只读的.如果想要在闭包内部改变闭包外变量,可将其变量加上<code>__block</code>标识符(两个下划线),这样编译器会将存于栈中的该变量转存到堆中.当闭包执行完之后,会将其信息复制到堆中的该变量然后复制到栈中.对于实例变量,通过setter和getter方法来改变它的值.因为它是存于堆中,所以不必加__block.</p>

<p>给block中的对象发送消息就会使得该变量引用计数次数加1,即会有一个strong pointer指向它.</p>

<p>某种程度上(存储block时)block可以看作对象,也有相应的引用计数(retaincount).但是它不能执行任何除<code>copy</code>方法外的方法.如下面示例</p>

<pre><code>//.h
@property (nonatmic,strong) NSArray *myBlocks;
//.m
//这一句存在着循环引用
[self.myBlocks addObject: ^{
    [self doit];
}];
//block的赋值
viod (^dosomething)(void) = self.myBlocks[0];
dosomething();
</code></pre>

<h4>循环引用</h4>

<p>在某些时候会造成循环引用的问题,因为闭包对闭包内所有的实例变量均为强引用,只要闭包还存留于堆当中.比如上面示例中block对self有强引用,同时self对block也有强引用,这时便产生了循环引用(retain cycle).</p>

<h4>解决方法</h4>

<pre><code>//循环引用的解决
__weak SomeClass *weakSelf = self;
[self.myBlocks addObject: ^{
    [weakSelf doit];
}];
</code></pre>

<p>这样便实现了循环引用的问题.这个时候block对weakSelf是弱引用而非强引用,所以不会产生类似问题.</p>

<h4>什么时候用到Block</h4>

<ul>
<li>枚举(Enumeration)</li>
<li>动画(View Animation)</li>
<li>排序(Sorting)</li>
<li>通知(Notification)</li>
<li>错误处理(Error handlers)</li>
<li>完成处理程序(Completion handlers)</li>
<li>多线程(Multithreading:Grand Central Dispatch)</li>
</ul>


<p>关于Block的更深层次的东西请看<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">谈Objective-C Block的实现</a></p>

<h4>动画 Animation</h4>

<p>UIView的类方法</p>

<pre><code>+ (void)animateWithDuration:(NSTimeInterval)duration
                      delay:(NSTimeInterval)delay
                     option:(UIViewAnimationOptions)options
                  animation:(void (^)void)animations
                 completion:(void (^)(BOOL finished))completion
</code></pre>

<h4>UIViewAnimationOptions</h4>

<ul>
<li>BeginFromCurrentState      // interrupt other, in-progress animations                                 of these properties</li>
<li>AllowUserInteraction       // allow gestures to get processed while                                   animation is in progress</li>
<li>LayoutSubviews             // animate the relayout of subviews along                                      with a parent’s animation</li>
<li>Repeat                     // repeat indefinitely</li>
<li>Autoreverse                // play animation forwards, then backwards</li>
<li>OverrideInheritedDuration  // if not set, use duration of any in-                                         progress animation</li>
<li>OverrideInheritedCurve     // if not set, use curve (e.g. ease-in/out)                                of in-progress animation</li>
<li>AllowAnimatedContent       // if not set, just interpolate between                                    current and end state image</li>
<li>CurveEaseInEaseOut         // slower at the beginning, normal                                         throughout, then slow at end</li>
<li>CurveEaseIn                // slower at the beginning, but then                                       constant through the rest</li>
<li>CurveLinear                // same speed throughout

<h4>力学性动画</h4></li>
<li>重力</li>
<li>撞击</li>
<li>外力作用</li>
<li>&hellip;&hellip;</li>
</ul>


<p>步骤:</p>

<blockquote><p>1 创建UIDynamicAnimator  <code>UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:aView];</code></p>

<p>2 为其添加UIDynamicBehaviors(如重力加速度,冲撞等)  <code>UIGravityBehavior *gravity = [[UIGravityBehavior alloc] init];</code>
<code>[animator addBehavior:gravity];</code></p>

<p>3 为UIDynamicBehaviors添加UIDynamicItems(通常是UIView)
<code>id &lt;UIDynamicItem&gt; item1 = ... ;</code></p>

<p><code>[gravity addItem:item1];</code></p></blockquote>

<pre><code>//UIDynamicItem protocol的内容
@protocol UIDynamicItem  
@property (readonly) CGRect bounds; 
@property (readwrite) CGPoint center; 
@property (readwrite) CGAffineTransform transform; 
@end 
</code></pre>

<p>如果想要改变<code>center</code>或者<code>transform</code>必须调用这个方法<code>- (void)updateItemUsingCurrentState:(id &lt;UIDynamicItem&gt;)item</code>,否则改变是无效的.</p>

<h4>一些力学行为的属性</h4>

<p>UIGravityBehavior</p>

<pre><code>@property CGFloat angle;    
@property CGFloat magnitude;  // 1.0 is 1000 points/s/s
</code></pre>

<p>UICollisionBehavior</p>

<pre><code>@property UICollisionBehaviorMode collisionMode;   //  Items,  Boundaries,  Everything (default)
-(void)addBoundaryWithIdentifier:(NSString *)identifier forPath:(UIBezierPath *)path;  
@property BOOL translatesReferenceBoundsIntoBoundary; 
</code></pre>

<p>其他的动态力学行为参见官方文档.</p>

<h4>UIDynamicItemBehavior</h4>

<pre><code>@property BOOL allowsRotation; 
@property BOOL friction; 
@property BOOL elasticity;  
@property CGFloat density;   
- (CGPoint)linearVelocityForItem:(id &lt;UIDynamicItem&gt;)item;  
- (CGFloat)angularVelocityForItem:(id &lt;UIDynamicItem&gt;)item; 
</code></pre>

<h4>UIDynamicBehavior</h4>

<p>它是所有动态力学行为的父类,自定义行为可继承自UIDynamicBehavior.
所有的Behavior都知道自己属于哪个UIDynamicAnimator,因为它们只能同时属于一个Animator.</p>

<p>很重要的一个属性<code>@property (copy) void(^action)(void)</code>在action里面不要执行耗时的操作,以免影响动画的进行.</p>

<h4>Demo</h4>

<p>继承UIDynamicBehavior,自定义力学行为</p>

<pre><code>//复写init方法,为子DynamicBehavior添加各种力学行为,如重力,冲撞等等
- (instancetype)init
  {
    self = [super init];
    [self addChildBehavior:self.gravity];
    ...     
    return self;
  }
</code></pre>

<h1><a id="8"></a>8.AutoLayout</h1>

<hr />

<p>通过约束条件而非数字来控制视图的尺寸.</p>

<p>在Xcode中预览旋转后视图的变化(无需启动模拟器):<em>选中某个Controller&mdash;>Attribute Inspector&mdash;>Oreintation</em>.</p>

<p>添加约束的三种方法:1.通过blue guideline 2.用界面右下角的菜单栏 3.ctrl+鼠标点击</p>

<h1><a id="9"></a>9.Multithreading、UIScrollingView、UITableView</h1>

<hr />

<h4>在其它队列上(queue)执行block</h4>

<pre><code>dispatch_queue_t queue = ...;//创建block将要执行的队列
dispatch_async(queue,^{});
</code></pre>

<h4>获取main queue</h4>

<pre><code>dispatch_queue_t mainQ = dispatch_get_main_queue();    
NSOperationQueue *mainQ = [NSOperationQueue mainQueue]; // for object-oriented APIs
</code></pre>

<h4>创建队列(非mainqueue)</h4>

<pre><code>dispatch_queue_t otherQ = dispatch_queue_create(“name”, NULL); //  name a const char *!name是一个常量指针非NSString
</code></pre>

<h4>主线程上调用某方法</h4>

<pre><code>//NSObject  method … !
- (void)performSelectorOnMainThread:(SEL)aMethod  
                         withObject:(id)obj  
                      waitUntilDone:(BOOL)waitUntilDone;
//for non-object-oriented APIs,NULL意味着serial queue即顺
//序队列,非并发队列(concurrent),该函数是线程安全的
dispatch_async(dispatch_get_main_queue(), ^{ /*  call  aMethod */  });
</code></pre>

<h4>下载</h4>

<pre><code>NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration    
                delegate:nil   
           delegateQueue:[NSOperationQueue mainQueue]];     
NSURLSessionDownloadTask *task;   
task = [session downloadTaskWithRequest:request     
                      completionHandler:^(NSURL *localfile, NSURLResponse *response, NSErr or *error) {    
/*  yes, can do UI things directly because this is called on the main queue */    
}];   
//记得给task加上resume,因为上面并不会马上进行,调用resume方法会使得下载
//任务马上进行
[task resume]; 
</code></pre>

<h4>UIScrollView</h4>

<p>几个重要的属性<code>contentSize</code>,<code>contentOffset</code>contentOffset这个属性表示当前视图左上角与content的左上角的x,y的偏移量.<code>scrollView.bounds</code>表示当前所见区域.</p>

<p>将当前可见区域转化成content所在坐标系的坐标
<code>CGRect visibleRect = [scrollView convertRect:scrollView.bounds toView:subview];</code>
在创建UIScrollView时不要忘记设置contentSize,在需要reset的时候也不要忘记reset.最好将设置contentSize的方法发在,随时要改变view大小的方法中.</p>

<pre><code>//滑至指定区域
- (void)scrollRectToVisible:(CGRect)aRect animated:(BOOL)animated;
</code></pre>

<h4>缩放(Zooming)</h4>

<p>要想缩放生效,必须<em>1.设置最小/最大缩放比例.2.实现代理方法<code>
- (UIView *)viewForZoomingInScrollView:(UIScrollView *)sender;</code></em></p>

<pre><code>//关于缩放的一些属性和方法
@property (nonatomic) float zoomScale;  !
- (void)setZoomScale:(float)scale animated:(BOOL)animated;  
- (void)zoomToRect:(CGRect)zoomRect animated:(BOOL)animated;   
- (void)scrollViewDidEndZooming:(UIScrollView *)sender      
                       withView:(UIView *)zoomView 
                        atScale:(CGFloat)scale;
</code></pre>

<h4>Demo</h4>

<p>让imageView自适应image可调用<code>[imageView sizeToFit]</code>方法。</p>

<p>如果自己复写了某属性的getter和setter方法就不要在用_someThing而是使用self.someThing.</p>

<p>prepareForSegue方法发生在oulet被设置之前.</p>

<p>NSURLSessionConfiguration有三个类构造函数，这很好地说明了NSURLSession是为不同的用例而设计的。相关介绍可以看这里<a href="http://jishu.zol.com.cn/201091.html">iOS 7系列译文：忘记NSURLConnection，拥抱NSURLSession吧！</a></p>

<pre><code>//返回标准配置，这实际上与NSURLConnection
//的网络协议栈是一样的，具有相同的共享NSHTTPCookieStorage，共享
//NSURLCache和共享NSURLCredentialStorage。
+ defaultSessionConfiguration

//返回一个预设配置，没有持久性存储的缓存，Cookie或证书。
//这对于实现像秘密浏览功能的功能来说，是很理想的。
+ ephemeralSessionConfiguration

//独特之处在于，它会创建一个后台会话。
//后台会话不同于常规的，普通的会话，它甚至可以在应用程序挂起，退出，崩溃的
//情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外
//恢复后台传输的守护进程提供上下文。
+ backgroundSessionConfiguration:(NSString *)name
</code></pre>

<p>在下载时,最好判断request.URL和imgurl是否一致.</p>

<h1><a id="10"></a>10.UITableView</h1>

<h4>TableView的种类</h4>

<ul>
<li><em>Plain or Grouped</em></li>
<li><em>Static or Dynamic</em>:静态一般用作设置之类的,动态是用来加载数据之类的</li>
<li><em>Devided into sections or not</em></li>
<li><em>Different formats for each row in the table</em></li>
</ul>


<h4>tableView的分布</h4>

<p><img src="/images/blogimg/stanford/header_footer.png" alt="" /></p>

<h4>Cell的样式</h4>

<ul>
<li><em>Subtitle(UITableViewCellStyleSubtitle)</em></li>
<li><em>Basic(UITableViewCellStyleDefault)</em></li>
<li><em>Right/Left Detail(UITableViewCellStyleValue1/Value2)</em></li>
</ul>


<p>一定要记得为不同的cell设置标识符(<code>identifier</code>)。</p>

<h4>两个协议UITableViewDelegate、UITableViewDataSource</h4>

<p><code>delegate</code>用来控制<code>tableview</code>如何被显示的,<code>datasource</code>为<code>cell</code>的各种显示细节提供数据。如果给一个非<code>TableviewController</code>添加<code>tableview</code>,一定要记住给这个tableview添加<code>delegate</code>和<code>datasource</code>即</p>

<pre><code>self.tableview.delegate = self;
self.tableview.dataSource = self;
</code></pre>

<p>dataSource的几个除返回row和section外的重要的方法</p>

<pre><code>//only for dynamic ones
- (UITableViewCell *)tableView:(UITableView *)sender
cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    cell = [dequeueReusableCellWithIdentifier: forIndexPath:];
}
在prepareForSegue方法中调用indexPathForCell:方法,
可以获取当前的cell  index
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender     
{      
    NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];     
//  prepare  segue.destinationController to display based on information  
//   about my Model corresponding to  indexPath.row  in  indexPath.section 
}
</code></pre>

<h1><a id="11"></a>11.Document&amp;Core Data</h1>

<p><code>NSManagedObject</code>是<code>CoreData</code>所有类的根类</p>

<p>获取<code>NSManagedObjectContext</code>,有两种方法</p>

<pre><code>1.创建UIManagedDocument,然后可以取得其属性managedObjectContext
2.创建工程时,勾选"use core data"
</code></pre>

<p>创建<code>UIManagedDocument</code></p>

<pre><code>NSFileManager *fileManager = [NSFileManager defaultManager]; 
NSURL *documentsDirectory = [[fileManager URLsForDirectory:NSDocumentDirectory 
                                            inDomains:NSUserDomainMask] firstObject]; 
NSString *documentName = @“MyDocument”; 
NSURL *url = [documentsDirectory URLByAppendingPathComponent:documentName]; 
UIManagedDocument * document = [[UIManagedDocument alloc] initWithFileURL:url]; 
</code></pre>

<p>上面代码段创建了<code>UIManagedDocument</code> 实例,但没有打开也没有生成相应文件</p>

<h4>怎么打开或者创建<code>UIManagedDocument</code> ?</h4>

<pre><code>//1.先检测UIManagedDocument 的底层文件是否存在
BOOL fileExists =  [[NSFileManager defaultManager] fileExistsAtPath:[url path]];,
//如果存在,则打开
[document openWithCompletionHandler:
^(BOOL success) { /* block to execute when open */  }];
//如果不存在,则创建,url应该用document.fileURL属性作参数
[document saveToURL:url 
   forSaveOperation:UIDocumentSaveForCreating
   competionHandler:^(BOOL success) { /* block to execute when create is done */  }];  

//下面是一段完整的代码,documentIsReady是一个自定义方法,在打
//开或创建成功后才执行的代码
self.document = [[UIManagedDocument alloc]initWithFileURL: (URL *)url];   
if ([[NSFileManager defaultManager]  fileExistsAtPath:[url path]]) {   
[document openWithCompletionHandler: ^(BOOL success) {    
    if (success) [self documentIsReady];   
    if (!success) NSLog(@“couldn’t open document at %@”, url);  
}];  
} else {  
    [document saveToURL:url forSaveOperation:UIDocumentSaveForCreating  
   completionHandler: ^(BOOL success) {    
    if (success) [self documentIsReady];   
    if (!success) NSLog(@“couldn’t create document at %@”, url);  
    }];  
}  
// can’t do anything with the document yet (do it in  documentIsReady).
//打开或创建成功后,就可使用了,最好对document的状态做个判断
- (void) documentIsReady  
{    
     if (self.document.documentState ==  UIDocumentStateNormal ) {    
         // start using document  
    }     
}
</code></pre>

<h4>ducument的状态还有下面几个</h4>

<ul>
<li>UIDocumentStateClosed</li>
<li>UIDocumentStateSavingError</li>
<li>UIDocumentStateEditingDisabled</li>
<li>UIDocumentStateInConflict

<h4>document的关闭与保存</h4></li>
<li><h5>关闭</h5>

<p>  在没有被强引用时就会自动关闭,也可以用下面方法来关闭它,它是异步的
  <code>[self.document closeWithCompletionHandler:^(BOOL success) {    
  if (!success) NSLog(@“failed to close document %@”,  self.document.localizedName); }];</code></p></li>
<li><h5>保存</h5>

<p>  document会自动保存,如果需要手动保存(也是异步的),可以使用下面方法(将会在主线程上被调用)
  <code>[document saveToURL:document.fileURL   
 forSaveOperation:UIDocumentSaveForOverwriting   
 competionHandler:^(BOOL success) { /* block to execute when save is done */  }];</code></p>

<h4>监听document的managedObjectContext</h4>

  //center为[NSNotificationCenter defaultCenter]
  //开启监听

<ul>
<li>(void)viewDidAppear:(BOOL)animated  <br/>
{  <br/>
  [super viewDidAppear:animated];    <br/>
  [center addObserver:self   <br/>
             selector:@selector(contextChanged:)
                 name:NSManagedObjectContextDidSaveNotification
               object:document.managedObjectContext];  //   不要传空值
}<br/>
//移除监听</li>
<li>(void)viewWillDisappear:(BOOL)animated   <br/>
{  <br/>
  [center removeObserver:self  <br/>
                    name:NSManagedObjectContextDidSaveNotification  <br/>
                  object:document.managedObjectContext];  <br/>
  [super viewWillDisappear:animated];  <br/>
}</li>
<li>(void)contextChanged:(NSNotification <em>)notification  <br/>
{
  //在这里处理context发生改变时需要进行的操作 <br/>
  // notification.userInfo拥有以下key(均为数组) <br/>
  //NSInsertedObjectsKey
  //NSUpdatedObjectsKey
  //NSDeletedObjectsKey
}<br/>
//在接收到通知时,可以通过调用下面方法来合并数据库的变化
//&ndash; (void)mergeChangesFromContextDidSaveNotification:(NSNotification   </em>)notification;

<h4>插入</h4>

NSManagedObjectContext <em>context = aDocument.managedObjectContext;<br/>
NSManagedObject </em>photo =<br/>
[NSEntityDescription insertNewObjectForEntityForName:@“Photo” inManagedObjectContext: context];<br/>
新插入对象的属性均为nil(除非在Xcode中指定一个默认值)

<h4>删除</h4>

<p>调用<code>[aDocument.managedObjectContext deleteObject:photo];</code> 即可.在删除该属性后,需要将指向它的强引用置nil.删除之后实体间的关系会自动更新.</p></li>
</ul>
</li>
</ul>


<p>也可以写一个分类,添加- (void)prepareForDeletion方法,在该方法中进行一些相应的操作.</p>

<h4>查询(Query)</h4>

<p>创建<code>NSFetchRequest</code>四要素</p>

<ul>
<li>想要获取的实体</li>
<li>一次性获取实体的数目(默认为全部实体)</li>
<li>用来指定返回顺序的NSSortDescriptor</li>
<li>用来指定获取哪些实体的NSPredicate</li>
</ul>


<p>创建的代码</p>

<pre><code>NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@“Photo”]; 
request.fetchBatchSize = 20; 
request.fetchLimit = 100;  
request.sortDescriptors = @[sortDescriptor]; 
request.predicate = ...;
</code></pre>

<h5>NSSortDescriptor</h5>

<p>`NSSortDescriptor *sortDescriptor =
 [NSSortDescriptor sortDescriptorWithKey:@“title”</p>

<pre><code>                           ascending:YES  
                            selector:@selector`(localizedStandardCompare :)]; 
</code></pre>

<h5>NSPredicate(谓词)</h5>

<p>明确指定我们需要从数据库得到的实例.当其为nil即意味着所有的.</p>

<pre><code>NSString *serverName = @“flickr-5”;  
NSPredicate *predicate =   
[NSPredicate predicateWithFormat:@“thumbnailURL contains %@”, serverName]; 
</code></pre>

<h5>NSCompoundPredicate(复合谓词)</h5>

<pre><code>NSArray *array = @ [predicate1, predicate2];  
NSPredicate *predicate = [NSCompoundPredicate andPredicateWithSubpredicates:array];
</code></pre>

<h5>高级查询</h5>

<ol>
<li>使用KVC(key value coding)</li>
</ol>


<p>可以使用谓词,比如<code>@“photos.@count &gt; 5”</code>,意味着所有大于5的Photographers.<code>@count</code>是database自执行的一个函数,还有一些其他类似的.</p>

<p>查看更多请点击<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueCoding/Articles/CollectionOperators.html">这里</a></p>

<h4>实例属性的获取</h4>

<pre><code>- (id)valueForKey:(NSString *)key; 
- (void)setValue:(id)value forKey:(NSString *)key;
//同样也可以用
valueForKeyPath: /setValue:forKeyPath:这两个方法会自动遵循实体之间的关系
</code></pre>

<p>同样我们可以通过Xcode来同时生成头文件(实体属性的property)和实现代码(实现代码里没有对@property进行@synthesize,需要注意)</p>

<h4>分类(Category)</h4>

<p>分类并不是子类,分类也有自己的.m和.h文件,同时它不能拥有实例变量,可以有属性变量(@property).分类中最好不要复写本类的原有方法.</p>

<h4>CoreData的线程安全</h4>

<p> <code>NSManagedObjectContext</code>是非线程安全的,通常coredata使用 <code>NSManagedObjectContext</code>非常迅速,所以多线程操作是没有必要的.</p>

<pre><code>[context performBlock:^{  // or performBlockAndWait:
// do stuff with context in its safe queue (the queue it was created on) !
}];  
</code></pre>

<h1><a id="12"></a>12. Core Data and Table View</h1>

<h4>NSFetchedResultsController</h4>

<p> <code>NSFetchedResultsController</code>和<code>NSFetchRequest</code>建立了相应联系,所以只要在<code>UITableViewDataSource</code>中使用即可(在UITableviewController中申明<code>NSFetchedResultsController</code>属性).比如</p>

<pre><code>- (NSUInteger)numberOfSectionsInTableView:(UITableView *)sender  
{  
    return [[self.fetchedResultsController sections] count];  
} 

- (NSUInteger)tableView:(UITableView *)sender numberOfRowsInSection:(NSUInteger)section  
{  
    return [[[self.fetchedResultsController sections] objectAtIndex:section] numberOfObjects];  
}  
</code></pre>

<p><code>UITableviewController</code>有一个比较常用的方法就是<code>objectAtIndexPath:</code>比如</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)sender  
     cellForRowAtIndexPath:(NSIndexPath *)indexPath  
{ 
    UITableViewCell *cell = ...; 
    NSManagedObject *managedObject =   // or, e.g.,  Photo *photo = (Photo *) … 
    [self.fetchedResultsController objectAtIndexPath:indexPath]; 
    // load up the cell based on the properties of the  managedObject !
    // of course, if you had a custom subclass, you’d be using dot notation to get them
    return cell; 
}
</code></pre>

<p>创建<code>UITableviewController</code></p>

<pre><code>NSFetchedResultsController *frc = [[NSFetchedResultsController alloc] 
initWithFetchRequest:(NSFetchRequest *)request 
managedObjectContext:(NSManagedObjectContext *)context 
  sectionNameKeyPath:(NSString *)keyThatSaysWhichSectionEachManagedObjectIsIn 
           cacheName:@“MyPhotoCache”];//cacheName可为nil,这里的cache必须为同一个NSFetchRequest下的cache
</code></pre>

<p><code>UITableviewController</code>会&#8221;监听&#8221;coredata的变化,然后自动更新列表.使用的是KVO(key-value observing)机制,当&#8221;监听&#8221;到变化,它会发送像下面的消息给它的delegate.</p>

<pre><code>- (void)controller:(NSFetchedResultsController *)controller 
didChangeObject:(id)anObject 
    atIndexPath:(NSIndexPath *)indexPath 
  forChangeType:(NSFetchedResultsChangeType)type 
   newIndexPath:(NSIndexPath *)newIndexPath 
{ 
    //这里可以调用tablevie的一些方法来更新列表
}
</code></pre>

<h1><a id="13"></a>13.其他</h1>

<blockquote><ul>
<li>关于视频:我已经打包好了,包括视频,源码,以及每节课的slides以及Assignments。下载请戳<a href="http://pan.baidu.com/s/1gdqTYPd">这里</a>
-本文将不断更新,如果发现文中的问题,请在评论中指出,谢谢。</li>
</ul>
</blockquote>
</div>

</article>

	<div class="share">
<!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<a class="jiathis_button_tsina"></a>
<a class="jiathis_button_tqq"></a>
<a class="jiathis_button_renren"></a>
<a class="jiathis_button_qzone"></a>
<a href="http://www.jiathis.com/share?uid=1872349" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
	data_track_clickback:true,
	summary:"",
	shortUrl:true,
	hideMore:false
}
</script>
<!-- JiaThis Button END -->

    
    
</div>


	

<DIV style="font-size:12px;BORDER-BOTTOM: #bbbbbb 1px solid; BORDER-LEFT: #bbbbbb 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 120px; BORDER-TOP: #bbbbbb 1px solid; BORDER-RIGHT: #bbbbbb 1px solid" class=oec2003right> 
<DIV style="MARGIN-TOP: 10px; FLOAT: left; MARGIN-LEFT: 5px; MARGIN-RIGHT: 10px"> 
<IMG alt="" src="http://www.gravatar.com/avatar/f174b807078512e658f34796ff85c47d?s=160" width=100 height=100></DIV> 
<DIV style="LINE-HEIGHT: 200%; MARGIN-TOP: 10px; COLOR: #000000"> 

作者： <A href="http://wang9262.github.io">VongLo</A> <BR> 
出处： <A href="http://wang9262.github.io">http://wang9262.github.io</A> 
<BR>本文基于<a target="_blank" title="署名-非商业性使用-相同方式共享 3.0 中国大陆" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/"> 
署名-非商业性使用-相同方式共享 3.0 中国大陆</a>许可协议发布<br/>欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接以及作者（上方两项信息）否则：保留追究法律责任的权利。 
</DIV></DIV> 


<section>
    <h1></h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-author-key=“1”></div>
<script type="text/javascript">
    var duoshuoQuery = {short_name:"wang9262"};
    (function() {
     var ds = document.createElement('script');
     ds.type = 'text/javascript';ds.async = true;
     ds.src = 'http://static.duoshuo.com/embed.js';
     ds.charset = 'UTF-8';
     (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
     })();
    </script>
<!-- Duoshuo Comment END --></div>
</section>
</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2014- 
 <a href="/">VongLo</a>-
  <span class="credit">Powered by <a href="http://octopress.org/">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			

<script type="text/javascript">
      var disqus_shortname = 'wang9262';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://wang9262.github.io/blog/2014/03/01/stanford-ios7-learning/';
        var disqus_url = 'http://wang9262.github.io/blog/2014/03/01/stanford-ios7-learning/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>









<!-- JiaThis Button BEGIN -->
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1872349" charset="utf-8"></script>

<!-- GoStats JavaScript Based Code -->
<script type="text/javascript" src="http://gostats.cn/js/counter.js"></script>
<script type="text/javascript">_gos='monster.gostats.cn';_goa=469994;
_got=7;_goi=3;_goz=0;_god='hits';_gol='';_GoStatsRun();</script>
<noscript><a target="_blank" title="" 
href="http://gostats.cn"><img alt="" 
src="http://monster.gostats.cn/bin/count/a_469994/t_7/i_3/z_0/show_hits/counter.png" 
style="border-width:0" /></a></noscript>
<!-- End GoStats JavaScript Based Code -->

		</div>
	</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | VongLo's Dev Space]]></title>
  <link href="http://wang9262.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://wang9262.github.io/"/>
  <updated>2014-07-14T23:16:48+08:00</updated>
  <id>http://wang9262.github.io/</id>
  <author>
    <name><![CDATA[VongLo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift学习笔记]]></title>
    <link href="http://wang9262.github.io/blog/2014/06/19/swift/"/>
    <updated>2014-06-19T22:49:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2014/06/19/swift</id>
    <content type="html"><![CDATA[<p>前几周,不仅仅iOS圈,很多程序员们都将目光聚集到Swift上.本文是学习Swift中的一些笔记,高手请绕道,纯属是从新手学习的角度记录,不断更新。</p>

<!--more-->


<p>
可能排版比较凌乱,将就一下。</p>

<h2>集合</h2>

<p>Dictionary中的key或者value都不必是object。collection are types collections。数组中的值必须是同种类型，字典型中的每对key和value必须是同种类型。</p>

<p>数组直接添加值
```</p>

<pre><code>var array = ["wwdc","session","world","you"]
//尾部添加
array += “hello” //array:wwdc,session,world,you,hello
//修改某个值
array[0] = "me"//array:me,session,world,you,hello
//替换某个范围的值
array[0...2] = ["banana","apple"]//array:banana,apple,you,hello
//插入
array[1..1] = ["fruit","peach"]//array:banana,fruit,peach,apple,you,hello
</code></pre>

<p>```</p>

<h3>字典类型的赋值与拷贝</h3>

<p>将字典实例赋值给一个常量或变量，或者传递给一个函数或方法，这个字典会在赋值或调用时进行拷贝。
```</p>

<pre><code>var ages = ["Peter": 23, "Wei": 35, "Anish": 65, "Katya": 19]
var copiedAges = ages
copiedAges["Peter"] = 24
println(ages["Peter"])
// 输出 "23"
</code></pre>

<p>```</p>

<h3>数组类型的赋值与拷贝</h3>

<p>如果对数组进行赋值或者参数传递给函数或方法时，其内容将不会被拷贝。拷贝仅仅当操作有可能改变数组长度时才会发生。可以通过调用<code>unshare</code>方法来确定数组引用唯一性，当其赋值给常量时不能调用<code>unshare</code>方法。
```</p>

<pre><code>var a = [1,2,1]
var b = a
b[0] = 8
println(a[0])//8
b.unshare
b[0] = 9
println(a[0])//8
</code></pre>

<p><code>
通过调用数组的copy方法进行强制显式复制。这个方法对数组进行了浅拷贝（shallow copy），并且返回一个包含此拷贝数组的新数组。
</code></p>

<pre><code>var names = ["Mohsen", "Hilary", "Justyn", "Amy", "Rich", "Graham", "Vic"]
var copiedNames = names.copy()
copiedName[0] = "Mo"
println(name[0])
// 输出 "Mohsen"
</code></pre>

<p>```
Note:如果你仅需要确保你对数组的引用是唯一引用，请调用unshare方法，而不是copy方法。unshare方法仅会在确有必要时才会创建数组拷贝。copy方法会在任何时候都创建一个新的拷贝，即使引用已经是唯一引用。</p>

<h2>Swift与Objective中nil的区别</h2>

<p>swift中nil并不是一个指针，它表示特定类型的值不存在，所有类型（不仅仅是对象类型）的optional都可被置为nil。OC华中nil是指向不存在对象的指针。</p>

<h2>！&amp;&amp;？</h2>

<p>Swift引入了<code>Optional Value</code>，在声明时，我们可以通过在类型后面加一个？来将变量声明为 <code>Optional</code>(可选) 的。如果不是<code>Optional</code>变量，就必须为其赋初值，否则会报错。如果没有值，则可将其设置为<code>optional</code>。
```</p>

<pre><code>var a:String？  //此时a为optional value，其值为nil
a = "hello"
</code></pre>

<p><code>``
</code>Optional Value`其实就是一个包装，里面可能有值，也可能什么都没有。</p>

<h3>隐式解包</h3>

<p>通过结合<code>if</code>和<code>let</code>，即可进行隐式解包
```</p>

<pre><code>var aStr: String? = 3  
if let str = aStr {  
    //have content
} else {
    //have no content
}
</code></pre>

<p>```</p>

<h3>强制隐式解包</h3>

<p>将<code>!</code>放在<code>optional value</code>后面，可以进行强制解包。
更多内容请参见<a href="http://onevcat.com/2014/06/walk-in-swift/">行走于 Swift 的世界中</a></p>

<h2>Switch</h2>

<p>不再需要break，但是必须写上default，除非case中所有情况均列出。switch中的不一定是整型，所有对象类型和值类型都行。单个case中可以匹配多个值，或者范围值。</p>

<p>Swift 中的switch不会从上一个<code>case</code>分支落入到下一个<code>case</code>分支中,Swift 的这种避免默认落入到下一个分支中的特性意味着它的<code>switch</code> 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 <code>case</code>分支从而引发的错误。</p>

<h2>Function</h2>

<p>使用<code>func</code>关键字声明函数.</p>

<p>可以通过元组(Tuple)返回多个值。
```</p>

<pre><code>//通过tuple返回多个值
func hello()-&gt;(Int,Int,Int){
    return(1,2,3)
}
</code></pre>

<p><code>
支持变长参数
</code></p>

<pre><code>func sumOf(numbers: Int...) -&gt; Int {
    var sum = 0
    for number in numbers {
        sum += number
    }
    return sum
}
sumOf()
sumOf(42, 597, 12)
</code></pre>

<p>```
函数可以嵌套，可以作为另一个函数的返回值，也可以作为参数进行传递。函数只能有一个可变形参，并且只能出现在形参表的最后一个位置，乙方有多参数时产生歧义。</p>

<h2>Closure</h2>

<p>Swift中函数（func）其实就是有名字的闭包(closure)，或者说闭包是匿名函数。可以使用<code>{}</code>来声明匿名闭包，用<code>in</code>来是参数、返回类型与函数体隔开，如：
```</p>

<pre><code>number.map({
    (num:Int)-&gt;Int in
    let result = 2 * num
    return result
    })
//如果闭包类型已知，可直接不写变量和返回类型，上面代码可简化为
number.map({num in 2 * num})
//也可通过参数位置来使用参数，当函数最后一个参数为闭包时，可使用。这种闭包称之为Trailing Closure。
sort([1,5,3,4]){$0&gt;$1}//将[1,5,3,4]数组按从大到小排列
</code></pre>

<p>```</p>

<h2>Class</h2>

<p>不必<code>import xxxclass.h</code>,不必继承自基类，因为Swift不像OC那样拥有全局基类<code>NSObject</code></p>

<h3>Property</h3>

<p>Swift中实例变量和属性没有区别，它们是相同的，这是和OC不一样的地方。Swift提供后端存储机制（backing store），没必要自己定义，同时它也为所有后端存储的存取做了相关处理。</p>

<h4>Stored Property</h4>

<h4>Compute Property</h4>

<p>compute property没有后端存储，它只是在被调用时生成或者计算某些值</p>

<h4>Initializer</h4>

<h4>Method</h4>

<h3>Struct</h3>

<p>可以有属性和方法，如果方法要改变属性，则需在前面加上关键字<code>mutating</code></p>

<h2>Struct和Class的区别</h2>

<ul>
<li>结构体不能够继承</li>
<li>结构体是值传递（copy），Class是引用传递（reference）。

<h3>引用类型和值类型的区别</h3>

<code>
//声明一个常量，是对Window(frame:frame)的一个引用
let window = Window(frame:frame)，Window是class
//但是这个Window(frame:frame)实例不会被常量所影响，仍然可以改变其属性
window.title = "hello"
//因为是常量引用，所以如果将其设置为其它的对象，将会编译错误
window = Window(frame:frame1)//报错。
//声明一个结构体常量
let point = Point(x:0.0,y:0.0)
//改变其属性
point.x = 20.0 //报错，不能修改常量值
//假设该结构体有一个带有关键字mutating的方法，这个方法中改变了x的值
point.moveToTheRightBy(200.0) //仍然报错，因为point是常量
</code>

<h2>Enumeration</h2>

<p>  enum Planet : Int  {
      case  Mercury = 1 , Venus, Earth, Mars, Jupiter, Saturn,Uranus, Neptune
  }
  let earthNumber = Planet.Earth. toRaw()
  // earthNumber is 3</p></li>
</ul>


<p>可以使用integer型作为枚举的基础值，同样也可使用其它类型，如Sring或者char型。有些甚至没有基础值。枚举可以有原始值、基础值、关联值(associated value)甚至可以没有值。
```</p>

<pre><code>//关联值
enum TrainStatus { 
    case OnTime, Delayed(Int) 
    init() {  
    self = OnTime 
    } 
    var description: String { 
        switch self { 
            case OnTime: 
                return "on time" 
            case Delayed(let minutes): 
                return "delayed by \(minutes) minute(s)" 
        } 
    } 
}
var status = TrainStatus() 
println("The train is \(status.description)") 
//  The train is on time 
status = .Delayed(42) 
println("The train is now \( status.description )")  
// The train is now delayed by 42 minute(s)
//同样也可以声明嵌套类型
class Train { 
    enum  Status  { 
        case OnTime, Delayed(Int) 
        init() { 
            self = OnTime 
        } 
    var description: String { ... } 
    } 
    var status = Status()  
}
</code></pre>

<p>```
一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。</p>

<h2>Extension</h2>

<p>类似OC中的Categroy，有一点不同的是我们可以为所有命名的类型进行扩展(extend)，包括值类型。</p>

<h2>Generic</h2>

<p>泛型,在尖括号里写一个名字来创建一个泛型函数或者类型
```
struct Stack<T>  {</p>

<pre><code>var elements = T[]() 
mutating func push(element: T) {
    elements.append(element) 
        } 
mutating func pop() -&gt; T { 
    return elements.removeLast() 
        } 
}
</code></pre>

<p>var intStack = Stack<Int>()
intStack.push(50)
let lastIn = intStack.pop()
var stringStack = Stack<String>()
stringStack.push(&ldquo;Hello&rdquo;)
println(stringStack.pop())
func repeat<ItemType>(item: ItemType, times: Int) &ndash;> ItemType[] {</p>

<pre><code>var result = ItemType[]()
for i in 0..times {
    result += item
    }
return result
}
</code></pre>

<p>repeat(&ldquo;knock&rdquo;, 4)
```</p>
]]></content>
  </entry>
  
</feed>

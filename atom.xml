<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[VongLo's Dev Space]]></title>
  <link href="http://wang9262.github.io/atom.xml" rel="self"/>
  <link href="http://wang9262.github.io/"/>
  <updated>2014-07-14T23:16:48+08:00</updated>
  <id>http://wang9262.github.io/</id>
  <author>
    <name><![CDATA[VongLo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最近随想及学期总结]]></title>
    <link href="http://wang9262.github.io/blog/2014/06/21/recent-thoughts/"/>
    <updated>2014-06-21T16:37:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2014/06/21/recent-thoughts</id>
    <content type="html"><![CDATA[<p> 今天6.21号，学校一年一届的毕业晚会——同歌同行如期进行，这也预示着我下一年也即将滚蛋,外面正进行着很High的泼水节,今年不像前两年那样去混进毕业游行队伍,觉得明年就到自己了,今年就不去凑热闹了.。昨天院里的毕业晚会，看了即将离开的学长学姐的各种有节操没节操的表演，觉得四年过的真的太快。回来的路上，jb说明年毕业晚会你也上去弹唱一首吧，感觉好伤感。
 <!--more--></p>

<p>这学期也马上要结束了，感觉学期初的计划只实现了一半。前期一直在忙着准备找实习，各种充电，从数据结构到算法，从C到Java,从Objective-C到iOS开发。感觉自己需要学的东西太多，而以前积累的知识完全不够。初期的网易终面被刷、去哪儿网笔试跪了、阿里内推电话面试之后没了下文、腾讯笔试没过、华为一面过后莫名其妙地没了下文，一系列的失败被拒让我一度陷入一个迷茫期，同时开始反省自己，然后一步步调整。五月过后，各大互联网公司基本已经结束了实习生的招聘，由于不想跟学校安排的实习，所以报了一个老师的实验室。看着课题是智慧老人系统，看着感觉比较对自己的兴趣，因为前期一直在做一个基于BLE4.0的智能家居的iOS客户端，觉着智能及自动化是未来的一个趋势。但是过去向老师进一步了解后，发现需要做的和我想的完全背道而驰，现在还在纠结要不要继续和他做下去。之后，又一家互联网公司到学校开宣讲会，以及现场笔试，笔试时感觉比较顺利，都是一些很基础的东西，虽然我的基础也并不扎实，但还是过了笔试，收到了第二天面试的通知。第二天的技术面和终面表现得都还可以，和面试官也很聊的来，两位面试官人都很nice。最后也收到了该公司的实习offer，感觉比较幸运。报的岗位是iOS，正对自己的兴趣，所以暑假过去要好好表现。</p>

<p>后期就是准备考试,感觉大三以来基本没听过课,都是沉浸在自己的世界里,看编程方面的书,看iOS的API文档。突然感觉自己的兴趣和专业已没多大联系了,这是不是一种悲哀呢?前期学业成绩感觉就那样了吧，达到了最低底线没有挂科，都是70左右在徘徊。接下来这几天也马上要考试,又得准备抱抱佛脚了,不得不先放放原来定的每天一个Session的计划了,等考完之后,再继续。</p>

<p>这学期的面试以及和一些人的接触过程中,有一些印象深刻的切身体会,那就是牛逼的人他们的说话方式都很有型，让人感觉什么事在他们眼中都不算问题。其实他们如今的对自己经历的一种轻描淡写甚至一笔带过，都是在经历了牛逼之前那段黑暗的迷茫期的磨练和铺垫后的一种释然。</p>

<p>接下来暑假期待完成的事有:</p>

<ul>
<li>实习到岗前,做一个小型的应用,争取上线。</li>
<li>实习期间,多多学习,去熟悉一个完整的大型的App的开发流程,好好表现争取转正。</li>
<li>加强基础,为秋招做准备。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift学习笔记]]></title>
    <link href="http://wang9262.github.io/blog/2014/06/19/swift/"/>
    <updated>2014-06-19T22:49:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2014/06/19/swift</id>
    <content type="html"><![CDATA[<p>前几周,不仅仅iOS圈,很多程序员们都将目光聚集到Swift上.本文是学习Swift中的一些笔记,高手请绕道,纯属是从新手学习的角度记录,不断更新。</p>

<!--more-->


<p>
可能排版比较凌乱,将就一下。</p>

<h2>集合</h2>

<p>Dictionary中的key或者value都不必是object。collection are types collections。数组中的值必须是同种类型，字典型中的每对key和value必须是同种类型。</p>

<p>数组直接添加值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var array = ["wwdc","session","world","you"]
</span><span class='line'>//尾部添加
</span><span class='line'>array += “hello” //array:wwdc,session,world,you,hello
</span><span class='line'>//修改某个值
</span><span class='line'>array[0] = "me"//array:me,session,world,you,hello
</span><span class='line'>//替换某个范围的值
</span><span class='line'>array[0...2] = ["banana","apple"]//array:banana,apple,you,hello
</span><span class='line'>//插入
</span><span class='line'>array[1..1] = ["fruit","peach"]//array:banana,fruit,peach,apple,you,hello</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>字典类型的赋值与拷贝</h3>

<p>将字典实例赋值给一个常量或变量，或者传递给一个函数或方法，这个字典会在赋值或调用时进行拷贝。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var ages = ["Peter": 23, "Wei": 35, "Anish": 65, "Katya": 19]
</span><span class='line'>var copiedAges = ages
</span><span class='line'>copiedAges["Peter"] = 24
</span><span class='line'>println(ages["Peter"])
</span><span class='line'>// 输出 "23"</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>数组类型的赋值与拷贝</h3>

<p>如果对数组进行赋值或者参数传递给函数或方法时，其内容将不会被拷贝。拷贝仅仅当操作有可能改变数组长度时才会发生。可以通过调用<code>unshare</code>方法来确定数组引用唯一性，当其赋值给常量时不能调用<code>unshare</code>方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a = [1,2,1]
</span><span class='line'>var b = a
</span><span class='line'>b[0] = 8
</span><span class='line'>println(a[0])//8
</span><span class='line'>b.unshare
</span><span class='line'>b[0] = 9
</span><span class='line'>println(a[0])//8</span></code></pre></td></tr></table></div></figure>


<p>通过调用数组的copy方法进行强制显式复制。这个方法对数组进行了浅拷贝（shallow copy），并且返回一个包含此拷贝数组的新数组。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var names = ["Mohsen", "Hilary", "Justyn", "Amy", "Rich", "Graham", "Vic"]
</span><span class='line'>var copiedNames = names.copy()
</span><span class='line'>copiedName[0] = "Mo"
</span><span class='line'>println(name[0])
</span><span class='line'>// 输出 "Mohsen"</span></code></pre></td></tr></table></div></figure>


<p>Note:如果你仅需要确保你对数组的引用是唯一引用，请调用unshare方法，而不是copy方法。unshare方法仅会在确有必要时才会创建数组拷贝。copy方法会在任何时候都创建一个新的拷贝，即使引用已经是唯一引用。</p>

<h2>Swift与Objective中nil的区别</h2>

<p>swift中nil并不是一个指针，它表示特定类型的值不存在，所有类型（不仅仅是对象类型）的optional都可被置为nil。OC华中nil是指向不存在对象的指针。</p>

<h2>！&amp;&amp;？</h2>

<p>Swift引入了<code>Optional Value</code>，在声明时，我们可以通过在类型后面加一个？来将变量声明为 <code>Optional</code>(可选) 的。如果不是<code>Optional</code>变量，就必须为其赋初值，否则会报错。如果没有值，则可将其设置为<code>optional</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a:String？  //此时a为optional value，其值为nil
</span><span class='line'>a = "hello"</span></code></pre></td></tr></table></div></figure>


<p><code>Optional Value</code>其实就是一个包装，里面可能有值，也可能什么都没有。</p>

<h3>隐式解包</h3>

<p>通过结合<code>if</code>和<code>let</code>，即可进行隐式解包</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var aStr: String? = 3  
</span><span class='line'>if let str = aStr {  
</span><span class='line'>  //have content
</span><span class='line'>} else {
</span><span class='line'>  //have no content
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>强制隐式解包</h3>

<p>将<code>!</code>放在<code>optional value</code>后面，可以进行强制解包。
更多内容请参见<a href="http://onevcat.com/2014/06/walk-in-swift/">行走于 Swift 的世界中</a></p>

<h2>Switch</h2>

<p>不再需要break，但是必须写上default，除非case中所有情况均列出。switch中的不一定是整型，所有对象类型和值类型都行。单个case中可以匹配多个值，或者范围值。</p>

<p>Swift 中的switch不会从上一个<code>case</code>分支落入到下一个<code>case</code>分支中,Swift 的这种避免默认落入到下一个分支中的特性意味着它的<code>switch</code> 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 <code>case</code>分支从而引发的错误。</p>

<h2>Function</h2>

<p>使用<code>func</code>关键字声明函数.</p>

<p>可以通过元组(Tuple)返回多个值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//通过tuple返回多个值
</span><span class='line'>func hello()-&gt;(Int,Int,Int){
</span><span class='line'>  return(1,2,3)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>
支持变长参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sumOf(numbers: Int...) -&gt; Int {
</span><span class='line'>  var sum = 0
</span><span class='line'>  for number in numbers {
</span><span class='line'>      sum += number
</span><span class='line'>  }
</span><span class='line'>  return sum
</span><span class='line'>}
</span><span class='line'>sumOf()
</span><span class='line'>sumOf(42, 597, 12)</span></code></pre></td></tr></table></div></figure>


<p>函数可以嵌套，可以作为另一个函数的返回值，也可以作为参数进行传递。函数只能有一个可变形参，并且只能出现在形参表的最后一个位置，乙方有多参数时产生歧义。</p>

<h2>Closure</h2>

<p>Swift中函数（func）其实就是有名字的闭包(closure)，或者说闭包是匿名函数。可以使用<code>{}</code>来声明匿名闭包，用<code>in</code>来是参数、返回类型与函数体隔开，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>number.map({
</span><span class='line'>  (num:Int)-&gt;Int in
</span><span class='line'>  let result = 2 * num
</span><span class='line'>  return result
</span><span class='line'>  })
</span><span class='line'>//如果闭包类型已知，可直接不写变量和返回类型，上面代码可简化为
</span><span class='line'>number.map({num in 2 * num})
</span><span class='line'>//也可通过参数位置来使用参数，当函数最后一个参数为闭包时，可使用。这种闭包称之为Trailing Closure。
</span><span class='line'>sort([1,5,3,4]){$0&gt;$1}//将[1,5,3,4]数组按从大到小排列</span></code></pre></td></tr></table></div></figure>


<h2>Class</h2>

<p>不必<code>import xxxclass.h</code>,不必继承自基类，因为Swift不像OC那样拥有全局基类<code>NSObject</code></p>

<h3>Property</h3>

<p>Swift中实例变量和属性没有区别，它们是相同的，这是和OC不一样的地方。Swift提供后端存储机制（backing store），没必要自己定义，同时它也为所有后端存储的存取做了相关处理。</p>

<h4>Stored Property</h4>

<h4>Compute Property</h4>

<p>compute property没有后端存储，它只是在被调用时生成或者计算某些值</p>

<h4>Initializer</h4>

<h4>Method</h4>

<h3>Struct</h3>

<p>可以有属性和方法，如果方法要改变属性，则需在前面加上关键字<code>mutating</code></p>

<h2>Struct和Class的区别</h2>

<ul>
<li>结构体不能够继承</li>
<li>结构体是值传递（copy），Class是引用传递（reference）。

<h3>引用类型和值类型的区别</h3></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//声明一个常量，是对Window(frame:frame)的一个引用
</span><span class='line'>let window = Window(frame:frame)，Window是class
</span><span class='line'>//但是这个Window(frame:frame)实例不会被常量所影响，仍然可以改变其属性
</span><span class='line'>window.title = "hello"
</span><span class='line'>//因为是常量引用，所以如果将其设置为其它的对象，将会编译错误
</span><span class='line'>window = Window(frame:frame1)//报错。
</span><span class='line'>//声明一个结构体常量
</span><span class='line'>let point = Point(x:0.0,y:0.0)
</span><span class='line'>//改变其属性
</span><span class='line'>point.x = 20.0 //报错，不能修改常量值
</span><span class='line'>//假设该结构体有一个带有关键字mutating的方法，这个方法中改变了x的值
</span><span class='line'>point.moveToTheRightBy(200.0) //仍然报错，因为point是常量</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Enumeration</h2>

<pre><code>enum Planet : Int  { 
    case  Mercury = 1 , Venus, Earth, Mars, Jupiter, Saturn,Uranus, Neptune 
} 
let earthNumber = Planet.Earth. toRaw() 
// earthNumber is 3
</code></pre>

<p>可以使用integer型作为枚举的基础值，同样也可使用其它类型，如Sring或者char型。有些甚至没有基础值。枚举可以有原始值、基础值、关联值(associated value)甚至可以没有值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//关联值
</span><span class='line'>enum TrainStatus { 
</span><span class='line'>  case OnTime, Delayed(Int) 
</span><span class='line'>  init() {  
</span><span class='line'>  self = OnTime 
</span><span class='line'>  } 
</span><span class='line'>  var description: String { 
</span><span class='line'>      switch self { 
</span><span class='line'>          case OnTime: 
</span><span class='line'>              return "on time" 
</span><span class='line'>          case Delayed(let minutes): 
</span><span class='line'>              return "delayed by \(minutes) minute(s)" 
</span><span class='line'>      } 
</span><span class='line'>  } 
</span><span class='line'>}
</span><span class='line'>var status = TrainStatus() 
</span><span class='line'>println("The train is \(status.description)") 
</span><span class='line'>//  The train is on time 
</span><span class='line'>status = .Delayed(42) 
</span><span class='line'>println("The train is now \( status.description )")  
</span><span class='line'>// The train is now delayed by 42 minute(s)
</span><span class='line'>//同样也可以声明嵌套类型
</span><span class='line'>class Train { 
</span><span class='line'>  enum  Status  { 
</span><span class='line'>      case OnTime, Delayed(Int) 
</span><span class='line'>      init() { 
</span><span class='line'>          self = OnTime 
</span><span class='line'>      } 
</span><span class='line'>  var description: String { ... } 
</span><span class='line'>  } 
</span><span class='line'>  var status = Status()  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>
一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。</p>

<h2>Extension</h2>

<p>类似OC中的Categroy，有一点不同的是我们可以为所有命名的类型进行扩展(extend)，包括值类型。</p>

<h2>Generic</h2>

<p>泛型,在尖括号里写一个名字来创建一个泛型函数或者类型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Stack&lt;T&gt;  { 
</span><span class='line'>  var elements = T[]() 
</span><span class='line'>  mutating func push(element: T) {
</span><span class='line'>      elements.append(element) 
</span><span class='line'>          } 
</span><span class='line'>      mutating func pop() -&gt; T { 
</span><span class='line'>          return elements.removeLast() 
</span><span class='line'>          } 
</span><span class='line'>  }
</span><span class='line'>var intStack = Stack&lt;Int&gt;() 
</span><span class='line'>intStack.push(50) 
</span><span class='line'>let lastIn = intStack.pop() 
</span><span class='line'>var stringStack = Stack&lt;String&gt;() 
</span><span class='line'>stringStack.push("Hello") 
</span><span class='line'>println(stringStack.pop())
</span><span class='line'>func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; ItemType[] {
</span><span class='line'>      var result = ItemType[]()
</span><span class='line'>      for i in 0..times {
</span><span class='line'>          result += item
</span><span class='line'>      }
</span><span class='line'>      return result
</span><span class='line'>  }
</span><span class='line'>repeat("knock", 4)</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Session 401:What's New In Xcode6]]></title>
    <link href="http://wang9262.github.io/blog/2014/06/19/whats-new-in-xcode/"/>
    <updated>2014-06-19T22:03:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2014/06/19/whats-new-in-xcode</id>
    <content type="html"><![CDATA[<p>每年WWDC的召开,都是iOS开发者极为关注的事情,除了Session 101的Keynote上的关于新操作系统特性介绍,甚至新设备的发布,还有更多让开发者能够快速适应这些新特性的Sessions。本文是在观看过程中记录的一些笔记。这里是Session 401 What&rsquo;s New In Xcode。</p>

<!--more-->


<p></p>

<ol>
<li><a href="#1">新特性概览</a></li>
<li><a href="#2">Swift</a></li>
<li><a href="#3">Interface Builder</a></li>
<li><a href="#4">visual debugging</a></li>
<li><a href="#5">性能测试</a></li>
</ol>


<h2><a id="1"></a>1.新特性概览</h2>

<ul>
<li>可以使用Storyboard为OS X设计APP</li>
<li>iOS在一个storyboard中设计iPhone和iPad应用，也可以自定义界面。</li>
<li>如果使用自定义字体，可以在Interface Builder中设置。</li>
<li>崭新的编辑器，比如Sprite Kit层级的编辑器，使场景可视化。</li>
<li>崭新的本地化方式，到处所有本地化内容到XLIFF，得到翻译后将其导入Xcode，Xcode会自动帮你把翻译合并到项目中。</li>
<li>iOS8开始对framework进行支持，可以通过添加关键字<code>@IBDesignale,@IBInspectable</code>设置IB Component。</li>
<li>调试更加方便，View Debugging。</li>
<li>Instruments有了全新的UI设计和新的工作流，更加简单地分析app性能。</li>
<li>可以给Bot添加自定义行为。</li>
<li>添加对XE Test Framework的支持，提高性能测试。</li>
</ul>


<h2><a id="2"></a>2.Swift</h2>

<p>同一个Target下的所有Swift的类对彼此都是可见的，但是需要导入依赖的framework。</p>

<p>在Swift文件中要使用OC中定义的类，导入
相反，在OC文件中要使用Swift中的类，导入<code>"import APPName-Swift.h"</code>即可</p>

<h2><a id="3"></a>3.Interface Builder</h2>

<p>在视图渲染前调用<code>prepareForInterfaceBuilder()</code>方法，可以在该方法中添加一些视图设置代码。</p>

<p><code>@IBInspectable</code>关键字使得Interface Builder自动生成一个可操作变量。设置断点，然后选中要检测的视图，在Editor->Debug Selected Views即可。</p>

<p>选中storyboard，点击File Inspector 勾选 <code>Use Size Classes</code>。修改Size classes的storyboard，可以同时修改iPad和iPhone的界面，如果只想修改其中一个的界面，点击底部的中间部分<code>wAnyhAny</code>，选中某个尺寸(iPhone或者iPad)即可单独修改其中一个的界面而不影响另一个。实时预览可以点击右下角第三个菜单->update constraints即可，前提是已打开预览界面。</p>

<h2><a id="4"></a>4.可视化调试(visual debugging)</h2>

<p>运行程序，在相应位置设置断点，然后重新进入对应的IB，对自动运行到断点处，选中相应的视图对象，然后通过Xcode的<code>Quick Look</code>功能，即可实时预览该视图。</p>

<p>在类中实现<code>- (id)debugQuickLookObject</code>方法，将想要在<code>Quick Look</code>中看到的东西作为该方法的返回值,然后Xcode会自动调用该方法来实现实时预览。</p>

<p>调试栏多出一项<code>Debug View Hierarchy</code>功能，在调试的时候能够看到所有label、textField等等的内容及相关属性。调节左边的<code>slider bar</code>，可以将视图按层次分离，调节右边的<code>slider bar</code>可以隐藏前面层级的视图。选中某个视图，点击底部菜单栏第二个选项，即可查看该视图的约束(constraints)，同时Xcode会自动将其他无关的view全部隐藏。</p>

<h2><a id="5"></a>5.性能测试</h2>

<p>新建一个<code>Test Case Class</code>,将其添加到<code>Test Target</code>中，它将自动生成好几个方法，这里重点讲的是<code>testPerformanceExample()</code>这个方法。实现该方法后，点击侧边栏的菱形状按钮，即可查看所消耗的时间。同时可以设置一个时间的基准值，来判断app的性能是否达到预期效果。如果不达标，左边的菱形将会出现一个<code>小红×</code>。如果在测试代码中无法检测到的性能可以使用<code>Instrument</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VM10装Mac OS X 10.9.3及更新到Mac OS X 10.10]]></title>
    <link href="http://wang9262.github.io/blog/2014/06/06/install-mac-os-x-10-dot-10-by-vmare/"/>
    <updated>2014-06-06T23:30:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2014/06/06/install-mac-os-x-10-dot-10-by-vmare</id>
    <content type="html"><![CDATA[<p>最近WWDC放出终极大招——新的编程语言Swift(雨燕),导致一大波程序员的围观和跃跃欲试。当然了,工欲善其事,必先利其器,所以对于那些没有Mac又想要尝鲜的小伙伴肯定很为难。但是，请放心，本文教你如何在Windows下也能体验Mac的滋味，当然咯，最主要的还是体验新的语言Swift。好了话不多说，直接开始，贴图比较多，耐心等待图的刷出。</p>

<!--more-->


<p></p>

<ol>
<li><a href="#1">所需软件</a></li>
<li><p><a href="#2">基本步骤</a></p>

<p> 2.1. <a href="#2.1">虚拟机的安装</a></p>

<p> 2.2. <a href="#2.2">插件安装</a></p>

<p> 2.3.  <a href="#2.3">Mac OS X 10.9.3的安装</a></p>

<p> 2.4.  <a href="#2.4">VMTool以及Darwin6.0.3的安装</a></p>

<p> 2.5.  <a href="#2.5">设置共享文件夹</a></p>

<p> 2.6 . <a href="#2.6">升级Mac OS X Yosemite</a></p>

<p> 2.6.1.<a href="#2.6.1">升级方法1</a></p>

<p> 2.6.2.<a href="#2.6.2">升级方法2</a></p></li>
<li><a href="#3">其他的一些tips</a></li>
<li><a href="#4">后续</a></li>
<li><a href="#5">关于一些问题反馈的更新</a></li>
</ol>


<h2><a id="1"></a>一、所需软件</h2>

<ul>
<li><p><a href="http://pan.baidu.com/s/1gdwyIcj">VMware Workstation 10 及注册机</a></p></li>
<li><p><a href="http://pan.baidu.com/s/1EPPh0">装Mac OS X插件</a></p></li>
<li><p><a href="http://pan.baidu.com/s/1ntJTd49">Mac OS X 10.9.3镜像</a></p></li>
<li><p><a href="http://yun.baidu.com/s/1sj6THFJ">10.10镜像 iso版</a></p></li>
<li><p><a href="http://yun.baidu.com/s/1bniZGmz">10.10镜像 dmg版</a></p></li>
<li><p><a href="http://pan.baidu.com/s/1ntyozI5">Xcode5.1.1</a></p></li>
<li><p><a href="http://pan.baidu.com/s/1c0pdrOW">Xcode6 Beta</a></p></li>
</ul>


<p>基本上所用到的软件都在上面了，点击即可下载，下面开始进入正题。</p>

<h2><a id="2"></a>二、基本步骤</h2>

<h3><a id="2.1"></a>1.虚拟机的安装</h3>

<p>下载上面的Vmare Workstation，以管理员身份运行，安装，一直下一步即可，别放C盘以免拖慢系统速度。VM安装好后，开始用注册机来激活，输入激活码即可。</p>

<h3><a id="2.2"></a>2.插件安装</h3>

<p>步骤一完成后，打开任务管理器，找到服务项，选择按名称排序，将框中四项全部停止运行。</p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/01.png" alt="" /></p>

<p>然后打开下载的插件，解压<code>unlock-all-v120.zip</code>文件，找到<code>
unlock-all-v120\windows\install.cmd</code>，右键以管理员身份运行，等待运行完即可。</p>

<h3><a id="2.3"></a>3.Mac OS X 10.9.3的安装</h3>

<p>相信你以上步骤已做好了，开启下面旅程吧。基本都是图片，所以很容易，just follow。</p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/02.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/03.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/04.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/05.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/06.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/07.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/08.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/09.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/10.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/11.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/12.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/13.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/14.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/15.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/16.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/17.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/18.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/19.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/20.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/21.png" alt="" /></p>

<p>然后出现苹果标志，稍等片刻，会出现语言选择，选择简体中文再下一步</p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/22.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/23.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/24.png" alt="" /></p>

<p>然后点击左上角的<code>磁盘工具</code>，选择<code>退出磁盘工具</code>。然后在安装界面点击<code>继续</code>,再点击<code>安装</code></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/25.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/26.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/27.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/28.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/29.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/30.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/31.png" alt="" /></p>

<p>安装完成，直接重启即可。至此，所有的安装步骤都完成了。</p>

<h3><a id="2.4"></a>4.VMTool以及Darwin6.0.3的安装</h3>

<p><img src="http://wang9262.github.io/images/blogimg/vm/32.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/33.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/34.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/35.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/36.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/37.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/38.png" alt="" /></p>

<h3><a id="2.5"></a>5.设置共享文件夹</h3>

<p><img src="http://wang9262.github.io/images/blogimg/vm/39.png" alt="" />
<img src="http://wang9262.github.io/images/blogimg/vm/40.png" alt="" /></p>

<p>共享文件夹的说明：由于虚拟机无法访问本机的硬盘，所以需要设置共享文件夹来方便虚拟机读取电脑的物理内存。</p>

<h3><a id="2.6"></a>6.升级Mac OS X Yosemite</h3>

<p>关于10.10 iso版需要说明一下,需将文件夹中两个文件都下载,两个都下载完后才能解压,解压<code>OS X 10.10 DP1 14A238x.zip</code>即可,<code>OS X 10.10 DP1 14A238x.z01</code>可以不用管,这是由于百度网盘上传文件大小设置,所以我将其切割成了两份。</p>

<h4><a id="2.6.1"></a>升级方法1</h4>

<p>下载10.10的iso镜像文件，将CD弹出，设置为10.10的镜像文件，然后连接CD即可，类似VMTool的安装。直接点击安装或下一步即可。</p>

<h4><a id="2.6.2"></a>升级方法2</h4>

<p>下载10.10的dmg镜像文件,将其拷入之前设置的共享文件夹内,然后在虚拟机中找到该dmg,双击运行即可。</p>

<h2><a id="3"></a>三、其他的一些tips</h2>

<p>当然你也可以直接装10.10(没有亲测),按照装10.9.3得步骤,应该也是可以的.可以尝试下,如果不能安装,可以再从10.9.3升级.如果直接安装,一定要用iso文件,很多人反馈说开启虚拟机就直接黑屏,主要是因为用的dmg镜像文件所导致。</p>

<p>当再次打开虚拟机时，发现进入的是下面界面</p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/41.png" alt="" /></p>

<p>之前装好的虚拟机不见了，不要着急,按照下图设置即可</p>

<p><img src="http://wang9262.github.io/images/blogimg/vm/42.png" alt="" /></p>

<p>是不是又出现了,接下来就尽情的玩耍吧，Xcode 6 是必不可少的啦。在安装的过程中,由于电脑配置等原因,安装的时间不一,所以大家要耐心等待下。</p>

<h2><a id="4"></a>四、后续</h2>

<p>我的电脑是win8，但是win7步骤基本一致，没有太大区别。还有一个就是AMD的貌似安装不了，只能intel的，如果你有好的方法，也可以分享下。如果你有疑问可在下面留言，也可以Email我。Have fun！</p>

<h2><a id="5"></a>五、关于一些问题反馈的更新</h2>

<p>经<a href="http://weibo.com/u/1697190022">@sinaguomq</a>反馈,当出现下列问题时</p>

<blockquote><p>二进制转换不支持用于 Mac OS X。要运行 Mac OS X，您需要一台 VMware Workstation 支持 Intel VT-x 或 AMD-V 的主机。 按着楼主的步骤一步一步来的，选择 开启此虚拟机 时弹出此错误。</p>

<blockquote><p>解决方法如下(处理器是intel)：
按 F10 键以配置 BIOS
使用箭头键滚动到“
onfiguration”
选择“Virtualization Technology”，然后按 Enter 键
选择“Enabled”，然后按 Enter 键
按 F10 键以保存并退出
选择“Yes”，然后按 Enter 键
完全关机（关闭电源），等待几秒钟，然后重新启动计算机</p></blockquote></blockquote>

<p>由于把所有东西都上传到百度网盘了,电脑上的就删了.忘了贴出hash码,经网友提醒将他得到的hash贴出来</p>

<blockquote><p>Mavercisk_Install_10.9.3_13D65_2.cdr</p>

<p>SHA1: E19BC6B5727699BF2A637D0102C89CC25CF37E67</p>

<p>OS X 10.10 DP1 14A238x.dmg</p>

<p>SHA1: 2E07E0C1864FD9015FFB04A436589D2E85D7EFEB</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[杭州网易行]]></title>
    <link href="http://wang9262.github.io/blog/2014/03/20/interview-of-netease-in-hangzhou/"/>
    <updated>2014-03-20T18:13:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2014/03/20/interview-of-netease-in-hangzhou</id>
    <content type="html"><![CDATA[<p>  周三接到网易电话，说上次电话面试通过了，让我周末过去杭州总部面试，于是周末就去了趟杭州。这篇文章是关于网易这次面试的相关内容和自己面试后的感想，写出来和大家分享一下。</p>

<!--more-->


<p></p>

<h2>面试过程</h2>

<p>3.4号接到网易的电话，说预约第二天下午三点进行电话面试，然后自己就开始准备自我介绍什么的。这里有个乌龙事件，之前投了份网易游戏的实习生，原来以为是游戏实习生的面试，几天之后接到网易游戏部的“虽然您很优秀&hellip;”的邮件，才知道原来游戏是招至少硕士学历的，这次电话面试并不是网易游戏的面试（后来才想起是之前投的网易iOS开发工程师实习生的职位，真囧~~）。</p>

<p>下面是第二天电话面试的大致内容，记得不是很清楚了，我大致还原一下当时的情景。忽略一些客气语，下面直接进入正题。</p>

<blockquote><p>面试官（以下以Q代替）：你学习iOS多长时间了？</p>

<p>我（下面以A代替）：十个月的样子。</p>

<p>Q：你了解MRC和ARC吗？</p>

<p>A：对他们都有一定的了解，但用的更多的是ARC，当然也知道MRC的规则及用法，也有做过相关Demo，由于开始学习iOS的时候ARC已经成为一种趋势，所以用的更多的是ARC。</p>

<p>Q：好的。你熟悉autorelease吗？谈谈它和ARC的区别是什么？</p>

<p>A：autorelease是将对象添加到NSAutoReleasePool里面，然后在调用<code>[pool drain]</code>方法后，所有在释放池里面的对象均被release。而ARC看起来的效果是一样的，但是实质是不一样的，ARC是系统在适当时候来释放一个对象的。</p>

<p>Q：嗯。你了解NSObject和NSObject Protocol吗？他们有什么区别，为什么要有NSobject Protocol？</p>

<p>A：NSObject几乎是iOS开发过程中所有类的根类，NSObject协议是为了方便一些并没有继承自NSObject的自定义类，来实现NSObject的一些方法，因为二者的方法大部分是一样的。</p>

<p>Q：那你知道哪些类是不继承自NSObject的？以及这样做的原因是什么？</p>

<p>A：据我目前见到的情况来看，貌似没有，但肯定有这种类。至于这样做的原因我不太清楚。（面试完后google了一下，大概了解了<a href="http://blog.csdn.net/linjinxing/article/details/9994903">相关情况</a>）</p>

<p>Q：你了解运行时吗？</p>

<p>A：了解一点点。</p>

<p>Q：嗯，没事，那你说说你了解的。</p>

<p>A：运行时就是在运行时来进行判断，比如内省。像<code>respondeToXXX</code>这些方法应该都是运行时才执行的。我知道的大概也就这么多了。</p>

<p>Q：你用过哪些开源库？</p>

<p>A：暑假做一个游戏客户端的时候用过CocoaAsyncSocket。</p>

<p>Q：你有仔细看过它的源码吗？你认为它的哪些方面可以优化呢？</p>

<p>A：当时项目比较紧，所以直接拿过来就用了，就看了一些自己需要用到的方法的实现。优化的话，暂时还没有想过。</p>

<p>Q：那如果你现在再去看这个开源库的时候你觉得你会学到哪些东西？</p>

<p>A：这个库是分TCP和UDP的，当时我们用的是TCP，这次如果再去看的话，应该对UDP也会有一定的了解和学习，同时也可以考虑一些可以优化的地方。</p>

<p>Q：对于其他的比较经典的关于网络方面的开源库还用过哪些？</p>

<p>A：AFNetwork，ASIHttp。</p>

<p>Q：嗯，其他的开源库呢？</p>

<p>A：用过那个在ios5，6下实现ios7扁平风格的控件的库，其他的都不记得名字了。</p>

<p>Q：你了解越狱吗？该怎么判断设备是否越狱？</p>

<p>A：了解一点点。您说的是只用代码判断吗？代码的话我不太清楚。（面试后google了一下，大致思想是检测是否多出越狱的文件目录，网上现成的代码也有，随便一搜就能搞定）</p>

<p>Q：了解copy和mutableCopy吗？谈谈二者的区别</p>

<p>A：了解。copy只是指针的复制，属于浅拷贝，mutableCopy是深拷贝。
（之后他举了个例子，忘记了，反正就是NSString和NSMutableString的一些东西。如果你有疑问，可以看看我之前的文章&mdash;><a href="http://wang9262.github.io/blog/2013/11/10/memory-manage/">OC内存管理学习</a>）</p>

<p>Q：怎么判断一个类是否遵循某个协议？</p>

<p>A：可以用respondTo协议里的某个方法来实现。</p>

<p>Q：还有没有其他的方法呢？</p>

<p>A：其他的应该有但是我不知道。因为我最常用的就是上面的这个方法。</p>

<p>Q：假如我有一个对象不想实现系统默认的方法，我能够做到吗？</p>

<p>A：可以用分类（categrey）吧，（迟疑片刻后想想不对），应该不行。（面试之后，自己再想了下应该可以复写其父类方法就行，不知道对不对）</p>

<p>Q：你用过GCD和NSOperation吗？它们常用的场景是什么？谈谈你的看法。</p>

<p>A：都用过。NSOperation是对GCD的封装，属于类级别的，GCD是底层的属于C级别的。GCD的效率可能会更高，因为基本上全是执行block。</p>

<p>Q：你平时用哪种方式呢？</p>

<p>A：一般图片加载用的是GCD，而其他下载任务用的是NSOperation。</p>

<p>Q：GCD能够随时停止吗？NSOperation呢？如果能的话又是调用什么方法呢？</p>

<p>A：GCD由于调用的是block，所以它一旦开始在执行完之前是不能停止或取消的。而Operation是可以的，通过KVO即可。当然如果要取消的话，我记得有个方法，名字貌似是close？（面完后查了下是cancel）</p></blockquote>

<p>之后就是换了一个人，问了下我的相关情况和实习时间的安排，然后让我等电话通知。</p>

<p>五天之后，接到电话，说让我周六下午去杭州面试。然后问了下费用问题，是不报销路费的，本来不打算去了，回来看看车费也不贵，于是想想觉得还是去吧。就算不过，也当长次经验还可以顺带去西湖看看。</p>

<p>坐了一晚的火车，第二天到网易大厦，一进大厅感觉自己是土鳖进城（哎，没见过世面）。下午一点到，在大厅等了45分钟，就有人过来叫我去面试，没想到这次还是技术面，本以为是HR面了。</p>

<p>进到玻璃间，面试官先问了我的一些情况，怎么来的，来这之后住哪里，看你精神不太好啊。我回“坐了通宵火车”等等。听声音感觉是和上一次电面的是同一个。</p>

<blockquote><p>Q：上次面完之后你有什么感想？面完之后有没有写blog什么的。</p>

<p>A：感觉自己很多方面的知识很薄弱，有待提高，blog倒是还没整理好，只是网上查了一下上次那些不知道的。</p>

<p>Q：那现在你对那些问题有了什么新的认识？</p>

<p>A：然后我就说了一下我对于那些知识的一个总结。</p>

<p>Q：有没有相关的项目经验呢？</p>

<p>A：帮一个公司做过一个类似QQ游戏大厅的客户端。实现登录以及各个游戏的在线人数显示，主要是从安卓端到iOS端的移植。</p>

<p>Q：那你对安卓应该也有所了解吧，说说他们之间的区别？</p>

<p>A：。。。谈了下自己的认识。</p>

<p>Q：除了这些，你自己平时有没有做过小的东西来玩一玩？</p>

<p>A：我掏出iTouch，然后拿出几个月前写的计算器给他看，然后介绍了下这个计算器实现的功能。</p>

<p>Q：（把玩了一下）嗯，看起来还不错，主要精力应该是花在了解析字符串上吧，UI有点。。。</p>

<p>A：确实，几乎都是字符串的解析，然后通过用数组来模拟栈进而实现括号的匹配。UI设计当时确实没怎么在意。（关于计算器，源代码戳<a href="https://github.com/wang9262/WLCalculator">这里</a>）</p>

<p>Q：这个好像是单机的，有没有做过网络方面的？</p>

<p>A：有过，去年的时候加校内的iOS团队，然后他们给我的任务是做一个RSS音乐播放器，主要实现XML的解析，然后下载，还有就是播放器的实现。</p></blockquote>

<p>然后我也记不清还问了哪些问题，紧接着他拿出一张纸，说这里有两个题目，你看下。先做第一题。一看全是逻辑题，突然觉得自己智商不够用。</p>

<blockquote><p>1.你到了一个十字路口，不知道该往哪边走。路口有两个人，一人只说真话，一人只说假话，但不知道谁说真话，谁说假话。问：你如何才能只问其中一个人问题，就能知道该走哪条路。</p>

<p>2.你到了一个是字轮芤，不知道该往哪边走。一条路通往真话村，一条通往假话村，真话村的人只讲真话，假话村的人只讲假话。这个时候你发现路口有一个人，很显然他不是真话村就是假话村的村民，现在你如何只问他一个问题，就能知道那条路通往假话村。</p></blockquote>

<p>看到第一题我想，这种题目应该是问其中一个人自带矛盾的问题，然后通过回答的内容来得出答案。虽然点子是对的，但是就是不知道怎么提问。这时候面试官在旁边说，你可以把你的想法说出来，然后我就说了一些。。但是又被自己否定了。然后他就开始提示我，一步步把我往答案的方向带，最后终于在他的点拨下得出了答案。第二题也是一样的情况，只不过一开始他说，这个题目我不会再给你提示了。然后。。我又开始想，好几分钟后，他又开始提示了，这样，又得出了答案。</p>

<p>最后他拿出一个算法题出来让我写，大致就是数电里面的摩根定理，比如NOT AND A，B转化为NOT A OR NOT B这样子。。我一开始说可以用栈来实现，但是仔细想想又不好确定，然后他又提示了，你看看二叉树会不会比栈方便些。大致思路如下</p>

<pre><code>    AND（not）             OR
     /  \       ---&gt;    /    \
    A    B             NOT   NOT
                        /     \
                       A       B
就是把前面有NOT的AND，将NOT作为它的tag，然后操作数分别作为其
左右孩子，这样进一步转化，将AND（not）转换成OR，not下移，操
作数随之移动。到最后，not均被移到底层，即可实现摩根定律。
</code></pre>

<p>然后就问我为什么要从事iOS开发？这之后就问我实习时间，然后问我还有没有什么疑问，说结果到时候会通知我。之后就是&#8221;Say GoodBye&#8221;了。</p>

<h2>一些感受</h2>

<p>这次面试之后总结了一下，发现自己的基础知识掌握的还不是很牢固，项目经验匮乏。尤其是逻辑推理题，自己的思路还不是很清晰，有待于训练。然后觉得很多面试，笔试有些片面，用这种算法题来考。如果有大量时间的话，那些刷题的人对于这些问题岂不是分分钟就解决了，工作后上手项目如果不能灵活运用是不是和当初的选拔目的相违背了。然后仔细想想，这也是没办法的办法，只能通过这种方式来筛选。这里仅仅是个人观点，如果让你觉得不爽请忽略。这两次面试过程中自己都没有紧张感产生，觉得不可思议，可能都是自己比较熟悉的东西，然后现场的气氛也很好的缘故吧，希望这种状态能延续下去。</p>

<p>最后，其实面试官人很好，很nice，在我回答不上的时候一直提示我。更重要的一点，此人有点像一初中同学，一见面就有种亲切感。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[斯坦福大学iOS7学习笔记]]></title>
    <link href="http://wang9262.github.io/blog/2014/03/01/stanford-ios7-learning/"/>
    <updated>2014-03-01T18:44:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2014/03/01/stanford-ios7-learning</id>
    <content type="html"><![CDATA[<p>其实这个视频出来也有一段时间了，但是由于各种原因一直拖到现在还没看完。这篇文章是我在观看视频以及自己Demo时的一些笔记记录,有些可能上下文不连贯,如果造成不便请理解,也可以留言指出。</p>

<!--more-->


<p>
<img src="http://wang9262.github.io/images/blogimg/stanford/description.png" alt="" /></p>

<ol>
<li><a href="#1">概览</a></li>
<li><a href="#2">objective-c</a></li>
<li><a href="#3">Foundation And Attributed Strings</a></li>
<li><a href="#4">View Controller Lifecycle</a></li>
<li><a href="#5">Polymorphism with Controllers, UI</a></li>
<li><a href="#6">手势、UIView、CoreGraphics</a></li>
<li><a href="#7">OC的一些语法特色&amp;Animation</a></li>
<li><a href="#8">AutoLayout</a></li>
<li><a href="#9">Multithreading、UIScrollingView、UITableView</a></li>
<li><a href="#10">UITableView</a></li>
<li><a href="#11">Document&amp;Core Data</a></li>
<li><a href="#12">Core Data and Table View</a></li>
<li><a href="#13">其他</a></li>
</ol>


<h1><a id="1"></a>1.概览(第一二集)</h1>

<hr />

<p>IBAction其实就是void</p>

<h1><a id="2"></a>2.objective-c</h1>

<hr />

<p>1.在数组中做插入时，应该先判断插入的位置是否越界。给数组发消息时，最好先判断数组是否为空</p>

<p>2.做输出口连接时，选择<code>Outlet Collection</code>(有三种:Outlet,Action,Outlet Collection)，默认为strong也必须为strong，view对每个输出口都有强引用，但是不会对输出口数组有强引用.当连接时，自动生成。如下图</p>

<p>  <img src="http://wang9262.github.io/images/blogimg/stanford/collection.png" alt="" /></p>

<p>如果设置为weak的话，将没有人对其有强引用，数组会持续为空。检查所有的输出口是否全部连接上，可以将鼠标放在property的前面实心圆点上，来观察所有的是否高亮。其中数组中的顺序是未知的</p>

<p>3.当要获取操作的对象在<code>collection</code>中的位置时，可以使用<code>[self.array indexOfObject:sender]</code>;<code>array</code>为<code>collection</code>生成的数组</p>

<p>4.<code>[array firstObject]</code>意义并不等同于 <code>array[0]</code>,当array为nil时，若用array[0]则会导致程序崩溃，而firstObject 则不会（此时return nil即返回nil）。</p>

<h1><a id="3"></a>3.Foundation And Attributed Strings</h1>

<hr />

<p>1.如果给NSString *str 发送[str mutable copy]将会产生一个可变的mutable String。</p>

<p>2.像firstObject、lastObject这种并没有产生新的对象，而是给你一个指向他们的指针。</p>

<p>3.给nil发送消息，将不会崩溃，相应得代码也不会被执行，如果该方法有返回值，则返回0或者nil.但是当返回值是C语言的结构体的话，将返回一个不确定的值，比如CGPoint p = [nil getLoction],此时p将是不确定的值。</p>

<p>4.动态绑定，id类型本身就是指针，所以不用加星号，指向一个不确定类型的对象。</p>

<p><img src="http://wang9262.github.io/images/blogimg/stanford/objec-pointer.png" alt="" /></p>

<p>运行时所有的对象指针均被当作id来对待。但是在编译时，如果你用比如NSString *而不是id，编译器会给你相应的提示，它可以帮你找出bug，给出适当的方法.</p>

<p>5.由于我们使用的是静态类型定义语言，并且编译器知道你的指针指向的类型.所以，动态绑定相对来说是安全的.但实际上还是有隐患的，比如：</p>

<p><img src="http://wang9262.github.io/images/blogimg/stanford/static.png" alt="" /></p>

<p>6.不要使用id *，因为这是指向指针的指针</p>

<p>7.些情况下，编译时会给出警告，而运行时不会崩溃，比如：</p>

<p><img src="http://wang9262.github.io/images/blogimg/stanford/warning.png" alt="" /></p>

<p>8.那么什么时候该用到id(动态绑定)呢？</p>

<p><img src="http://wang9262.github.io/images/blogimg/stanford/when-to-dynamic.png" alt="" /></p>

<p>要让他变得安全可以使用两种方式：内省（introspection）[即在运行时判断某个对象属于哪个类或者能给它发送什么样的消息]和协议（protocol）</p>

<p>9.所有继承自NSObject的类都有下面的方法</p>

<pre><code>isKindOfClass：某对象是否属于某个(包括继承)
isMemberOfClass：某对象是否属于某个类，(不包括继承)
respondsToSelector:某对象是否相应某个方法
</code></pre>

<p>上面三个方法都是在运行时来确定的。
一般的书写格式：</p>

<p><img src="http://wang9262.github.io/images/blogimg/stanford/run-timemodel.png" alt="" /></p>

<p>在数组中可以使用 makeObjectsPerformSelector使数组每个值都执行某个方法。</p>

<h4>Foundation Framework</h4>

<p>1.给可变的对象发送copy消息，返回的是不可变的对象。比如 *arr = [array copy]假设array为可变的。copy消息返回的不可变的，mutableCopy返回的是可变的(不管是给可变或者不可变的对象发送消息都是如此)
2.NSArray一些有意思的方法</p>

<p>  <img src="http://wang9262.github.io/images/blogimg/stanford/funnuy-NSArray.png" alt="" /></p>

<p>3.NSNumber的新语法</p>

<p>  <img src="http://wang9262.github.io/images/blogimg/stanford/NSNumber-new-syntax.png" alt="" /></p>

<p>4.NSDictionary（类似哈希表）</p>

<p>  <img src="http://wang9262.github.io/images/blogimg/stanford/NSDictionary.png" alt="" /></p>

<p>5.Property List （集合的集合） ：NSUserDefaults 就是一个典型的property list ，NSUserDefaults 通常只用来存储一些较小的东西，比如账号、密码最好别用来存储一些容量很大的东西，比如图片，NSData</p>

<p>6.在调用[[NSUserDefaults  standard]setobject:forKey]之后必须使用[[NSUserDefaults  standard] synchronize]是数据同步</p>

<p>7.NSRange   range = （i，j）它的范围是从第i个到i+j-1个。</p>

<p>  <img src="http://wang9262.github.io/images/blogimg/stanford/NSRange.png" alt="" /></p>

<p>8.UIColor：alpha（透明度，0代表全透明，1代表不透明）</p>

<p>9.UIFonts ：ios7种很大的一点改进就是对字体的支持更多元化</p>

<p>  <img src="http://wang9262.github.io/images/blogimg/stanford/UIFont.png" alt="" /></p>

<p>Attributed Strings</p>

<ol>
<li> NSAttributedString（类似NSString但是字符串中的每个字符都有自己的属性  并非NSString的子类）是不可变的（immutable）</li>
<li>  NSMutableAttributedString（使用的更多）</li>
<li> 所有的属性添加下划线</li>
</ol>


<p>  <img src="http://wang9262.github.io/images/blogimg/stanford/underline.png" alt="" /></p>

<h1><a id="4"></a>4.View Controller Lifecycle</h1>

<hr />

<h4>UITextView</h4>

<p>常用属性：
<code>UIFont *font，NSTextStorage *textStorage``NSTextStorage</code>是<code>NSMutableAttributedString</code>的子类，可以随意修改它，UITextView会自动更新修改后的内容。
在设置font的时候最好是为特定的字符或字符串设置font，不然会影响到性能.</p>

<h4>UIView LifeCycle</h4>

<p>不要在viewdidload方法里面设置一些尺寸会发生变化的控件</p>

<p>顺序
awakeFromNib->viewDidload->viewWillLayoutSubviews->viewDidiLayoutSubviews->viewWillAppear->viewDidAppear</p>

<p>1.viewwillappear只需一次性初始化的不要放在该方法中,最好放入viewdidiload.当展示的东西会发生改变时,可以将其放在该方法中,使其同步
一些网络延时等待可以放在这个方法中进而优化,减少等待时间.在该方法中来设置控件尺寸
viewwilldisappear 这个方法一般用来存储当前数据,用作恢复时的重载.</p>

<p>2.viewWill(did)LayoutSubviews (iOS6.0)最好在did里面来改变尺寸</p>

<p>3.awakeFromNib(storyboard)   在输出口被设置之前调用</p>

<p>想要了解更多情况可以看看<a href="http://blog.csdn.net/u012971918/article/details/16983499">理一理UIViewController的东东</a>。</p>

<h4>Notification</h4>

<p>在接收通知后如无需再监听,就<code>removeObeserver:self</code>，<code>viewWillAppear</code>里面添加通知监听同时执行监听到通知后应该执行的方法，在<code>viewWillDisappear</code>里面移除监听。</p>

<p><code>notification center</code>拥有一个<code>unsafe retained</code>指针指向监听者。<code>unsafe retained</code> 意味着如果将监听者移除堆栈却没有调用<code>remove</code>这个方法，<code>notification center</code>仍会向监听者发送notification，这个时候APP将会崩溃。之所以用<code>unsafe retained</code>是因为向前（ios 4、5）兼容的问题。</p>

<h1><a id="5"></a>5.Polymorphism with Controllers, UI</h1>

<hr />

<p>抽象类意味着该类不能被实例化，只能作为超类来给其他具体类来继承。在storyboard里面<code>ctrl+shift+单击</code>，会显示鼠标所在区域的所有东西。</p>

<p>具体类继承了抽象类的outlet以及Action（即使是private也能继承）</p>

<p>导航条上的button并非UIButton而是<code>UIBarButtonItems</code>（轻量级button）放置在<code>NavigationItem</code>上</p>

<p>下方为<code>toolbaritems</code></p>

<h4>segues</h4>

<p>要为每一个segue设置id以便辨识区分</p>

<h4>UINavigationController</h4>

<p>通过self.navigationcontroller来判断当前controller是否为UINavigationController。tabarcontroller同理</p>

<p>判断某个view是否为当前显示，可以用[view.window]是否为nil来判断。当某个view当前并没有显示，但是由于数据变化需要更新其UI，则可将UI更新代码放在viewWillAppear里。UI更新最好作为一个方法updateUI，以方便复用。</p>

<h4>UITabarController</h4>

<p>tabaritem的icon是30*30</p>

<h1><a id="6"></a>6.手势、UIView、CoreGraphics</h1>

<hr />

<h4>UIWindow</h4>

<p>view层级的顶层view，一般情况下一个APP只有一个UIWindow</p>

<p><code>initWithFrame</code>不能用于storyboard的view，可以用<code>awakeFromNib</code></p>

<h4>View的坐标系</h4>

<p>CGFloat:(x,y),CGSize:(width,height),CGRect:(CGFloat,CGSize)</p>

<p>bounds是自身坐标系，frame是父视图坐标系。</p>

<p>可在<code>drawRect</code>方法中对View进行自定义draw。不要调用drawRect，它是供系统调用的，但是可以复写。可以通过调用<code>setneedsdisplay</code>或者<code>setneedsdisplayinrect</code>，这两个方法会调用<code>drawrect</code>方法。</p>

<p>CoreGraphics利用UIBezierPath来完成画线 填色 线条粗细等操作</p>

<p>上下文<code>context</code>决定了画的位置,UIBezierPath在当前上下文<code>context</code>中画因此可以不用去得到上下文.如果要得到上下文可调用<code>CGContextRef context = UIGraphicsGetCurrentContext()</code>,这里直接调用了C函数.<code>CGContextRef</code>是一个void型指针.</p>

<h4>示例</h4>

<pre><code>//用UIBezierPath画三角形
UIBezierPath *path = [[UIBezierPath alloc]init];
[path moveToPoint:CGPointMake(75,10)];
[path addLineToPoint:CGPointMake(160,150)];
[path addLineToPoint:CGPointMake(10,150)];
[path closePath];
path.lineWidth = 3.0f;
//上面所有步骤并没有画出该三角形,仅仅是确定其大小
//需要加上以下几个方法调用才行
[[UIColor redColor]setFill];
[[UIColor blueColor]setStroke];
[path fill];
[path stroke];
</code></pre>

<p>还可以用贝塞尔曲线画各种形状,方法参见API.<code>[path addClip]</code>方法可以剪切出该封闭曲线内所画的内容.</p>

<p>如果要使view有透明度,首先需要将其opaque<code>@property BOOL opaque</code>属性设置为NO(但是对系统性能有一定影响).可以通过设置透明度<code>alpha</code>来改变整个view的透明度.</p>

<p>通过CGContext函数来生成图片</p>

<pre><code>UIGraphicsBeginImageContext(CGSize);
UIImage *image = UIGraphicsGetImageFromCurrentContext();
UIGraphicsEndInamgeContext();
</code></pre>

<p>在UIImage上作图</p>

<pre><code>[img drawAtPoint:point];
[img drawInRect:rect];
[img drawAsPatternInRect:rect];
</code></pre>

<h4>手势</h4>

<p>首先要使view添加手势才能识别,其次要实现手势识别的方法.</p>

<ul>
<li>UITapGestureRecognizer</li>
<li>UIPinchGestureRecognizer</li>
<li>UIRotationGestureRecognizer</li>
<li>UISwipeGestureRecognizer</li>
<li>UIPanGestureRecognizer //缓慢拖动</li>
<li>UILongPressGestureRecognizer</li>
</ul>


<h4>Demo</h4>

<p>NSParaGraphStyle来设置段落的一些属性.</p>

<p>字体的翻转
<code>CGContextTranslateCTM(context,x,y)</code>(x,y是要移动的距离,相对于当前坐标系)来移动,然后在设定角度来翻转即可<code>CGContextRotateCTM(context,M_PI)</code>.</p>

<h1><a id="7"></a>7.OC的一些语法特色&amp;Animation</h1>

<hr />

<h4>协议(Protocol)</h4>

<p>内省:有时有效,但不是主要编程方法,它是在运行时发生的.</p>

<p>Attention!在协议中也可以有属性(property)的申明.</p>

<p><em>NSObject Protocol</em>里面的方法和<em>NSObject</em>种方法是一样的,那为什么要有<em>NSObject protoclo</em>呢?这是作为给那些非<em>NSObject</em>的类在运行时来实现自省.(可以自定义某个类并非继承自NSobjec.如<code>@inteface MyObject</code>,并没有父类,但是经常不这么做,通常所有类都继承自<em>NSObject</em>).</p>

<h4>闭包(Block、closure)</h4>

<p>通常为 <code>^ int (int a,int b)</code>,^为block标识符,紧接着为返回类型,然后是变量.如果可以从其返回值推测其返回类型,可以省去返回值.(如省去int)</p>

<p>对于闭包外的局部变量,在闭包内使用时是只读的.如果想要在闭包内部改变闭包外变量,可将其变量加上<code>__block</code>标识符(两个下划线),这样编译器会将存于栈中的该变量转存到堆中.当闭包执行完之后,会将其信息复制到堆中的该变量然后复制到栈中.对于实例变量,通过setter和getter方法来改变它的值.因为它是存于堆中,所以不必加__block.</p>

<p>给block中的对象发送消息就会使得该变量引用计数次数加1,即会有一个strong pointer指向它.</p>

<p>某种程度上(存储block时)block可以看作对象,也有相应的引用计数(retaincount).但是它不能执行任何除<code>copy</code>方法外的方法.如下面示例</p>

<pre><code>//.h
@property (nonatmic,strong) NSArray *myBlocks;
//.m
//这一句存在着循环引用
[self.myBlocks addObject: ^{
    [self doit];
}];
//block的赋值
viod (^dosomething)(void) = self.myBlocks[0];
dosomething();
</code></pre>

<h4>循环引用</h4>

<p>在某些时候会造成循环引用的问题,因为闭包对闭包内所有的实例变量均为强引用,只要闭包还存留于堆当中.比如上面示例中block对self有强引用,同时self对block也有强引用,这时便产生了循环引用(retain cycle).</p>

<h4>解决方法</h4>

<pre><code>//循环引用的解决
__weak SomeClass *weakSelf = self;
[self.myBlocks addObject: ^{
    [weakSelf doit];
}];
</code></pre>

<p>这样便实现了循环引用的问题.这个时候block对weakSelf是弱引用而非强引用,所以不会产生类似问题.</p>

<h4>什么时候用到Block</h4>

<ul>
<li>枚举(Enumeration)</li>
<li>动画(View Animation)</li>
<li>排序(Sorting)</li>
<li>通知(Notification)</li>
<li>错误处理(Error handlers)</li>
<li>完成处理程序(Completion handlers)</li>
<li>多线程(Multithreading:Grand Central Dispatch)</li>
</ul>


<p>关于Block的更深层次的东西请看<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">谈Objective-C Block的实现</a></p>

<h4>动画 Animation</h4>

<p>UIView的类方法</p>

<pre><code>+ (void)animateWithDuration:(NSTimeInterval)duration
                      delay:(NSTimeInterval)delay
                     option:(UIViewAnimationOptions)options
                  animation:(void (^)void)animations
                 completion:(void (^)(BOOL finished))completion
</code></pre>

<h4>UIViewAnimationOptions</h4>

<ul>
<li>BeginFromCurrentState      // interrupt other, in-progress animations                                 of these properties</li>
<li>AllowUserInteraction       // allow gestures to get processed while                                   animation is in progress</li>
<li>LayoutSubviews             // animate the relayout of subviews along                                      with a parent’s animation</li>
<li>Repeat                     // repeat indefinitely</li>
<li>Autoreverse                // play animation forwards, then backwards</li>
<li>OverrideInheritedDuration  // if not set, use duration of any in-                                         progress animation</li>
<li>OverrideInheritedCurve     // if not set, use curve (e.g. ease-in/out)                                of in-progress animation</li>
<li>AllowAnimatedContent       // if not set, just interpolate between                                    current and end state image</li>
<li>CurveEaseInEaseOut         // slower at the beginning, normal                                         throughout, then slow at end</li>
<li>CurveEaseIn                // slower at the beginning, but then                                       constant through the rest</li>
<li>CurveLinear                // same speed throughout

<h4>力学性动画</h4></li>
<li>重力</li>
<li>撞击</li>
<li>外力作用</li>
<li>&hellip;&hellip;</li>
</ul>


<p>步骤:</p>

<blockquote><p>1 创建UIDynamicAnimator  <code>UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:aView];</code></p>

<p>2 为其添加UIDynamicBehaviors(如重力加速度,冲撞等)  <code>UIGravityBehavior *gravity = [[UIGravityBehavior alloc] init];</code>
<code>[animator addBehavior:gravity];</code></p>

<p>3 为UIDynamicBehaviors添加UIDynamicItems(通常是UIView)
<code>id &lt;UIDynamicItem&gt; item1 = ... ;</code></p>

<p><code>[gravity addItem:item1];</code></p></blockquote>

<pre><code>//UIDynamicItem protocol的内容
@protocol UIDynamicItem  
@property (readonly) CGRect bounds; 
@property (readwrite) CGPoint center; 
@property (readwrite) CGAffineTransform transform; 
@end 
</code></pre>

<p>如果想要改变<code>center</code>或者<code>transform</code>必须调用这个方法<code>- (void)updateItemUsingCurrentState:(id &lt;UIDynamicItem&gt;)item</code>,否则改变是无效的.</p>

<h4>一些力学行为的属性</h4>

<p>UIGravityBehavior</p>

<pre><code>@property CGFloat angle;    
@property CGFloat magnitude;  // 1.0 is 1000 points/s/s
</code></pre>

<p>UICollisionBehavior</p>

<pre><code>@property UICollisionBehaviorMode collisionMode;   //  Items,  Boundaries,  Everything (default)
-(void)addBoundaryWithIdentifier:(NSString *)identifier forPath:(UIBezierPath *)path;  
@property BOOL translatesReferenceBoundsIntoBoundary; 
</code></pre>

<p>其他的动态力学行为参见官方文档.</p>

<h4>UIDynamicItemBehavior</h4>

<pre><code>@property BOOL allowsRotation; 
@property BOOL friction; 
@property BOOL elasticity;  
@property CGFloat density;   
- (CGPoint)linearVelocityForItem:(id &lt;UIDynamicItem&gt;)item;  
- (CGFloat)angularVelocityForItem:(id &lt;UIDynamicItem&gt;)item; 
</code></pre>

<h4>UIDynamicBehavior</h4>

<p>它是所有动态力学行为的父类,自定义行为可继承自UIDynamicBehavior.
所有的Behavior都知道自己属于哪个UIDynamicAnimator,因为它们只能同时属于一个Animator.</p>

<p>很重要的一个属性<code>@property (copy) void(^action)(void)</code>在action里面不要执行耗时的操作,以免影响动画的进行.</p>

<h4>Demo</h4>

<p>继承UIDynamicBehavior,自定义力学行为</p>

<pre><code>//复写init方法,为子DynamicBehavior添加各种力学行为,如重力,冲撞等等
- (instancetype)init
  {
    self = [super init];
    [self addChildBehavior:self.gravity];
    ...     
    return self;
  }
</code></pre>

<h1><a id="8"></a>8.AutoLayout</h1>

<hr />

<p>通过约束条件而非数字来控制视图的尺寸.</p>

<p>在Xcode中预览旋转后视图的变化(无需启动模拟器):<em>选中某个Controller&mdash;>Attribute Inspector&mdash;>Oreintation</em>.</p>

<p>添加约束的三种方法:1.通过blue guideline 2.用界面右下角的菜单栏 3.ctrl+鼠标点击</p>

<h1><a id="9"></a>9.Multithreading、UIScrollingView、UITableView</h1>

<hr />

<h4>在其它队列上(queue)执行block</h4>

<pre><code>dispatch_queue_t queue = ...;//创建block将要执行的队列
dispatch_async(queue,^{});
</code></pre>

<h4>获取main queue</h4>

<pre><code>dispatch_queue_t mainQ = dispatch_get_main_queue();    
NSOperationQueue *mainQ = [NSOperationQueue mainQueue]; // for object-oriented APIs
</code></pre>

<h4>创建队列(非mainqueue)</h4>

<pre><code>dispatch_queue_t otherQ = dispatch_queue_create(“name”, NULL); //  name a const char *!name是一个常量指针非NSString
</code></pre>

<h4>主线程上调用某方法</h4>

<pre><code>//NSObject  method … !
- (void)performSelectorOnMainThread:(SEL)aMethod  
                         withObject:(id)obj  
                      waitUntilDone:(BOOL)waitUntilDone;
//for non-object-oriented APIs,NULL意味着serial queue即顺
//序队列,非并发队列(concurrent),该函数是线程安全的
dispatch_async(dispatch_get_main_queue(), ^{ /*  call  aMethod */  });
</code></pre>

<h4>下载</h4>

<pre><code>NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration    
                delegate:nil   
           delegateQueue:[NSOperationQueue mainQueue]];     
NSURLSessionDownloadTask *task;   
task = [session downloadTaskWithRequest:request     
                      completionHandler:^(NSURL *localfile, NSURLResponse *response, NSErr or *error) {    
/*  yes, can do UI things directly because this is called on the main queue */    
}];   
//记得给task加上resume,因为上面并不会马上进行,调用resume方法会使得下载
//任务马上进行
[task resume]; 
</code></pre>

<h4>UIScrollView</h4>

<p>几个重要的属性<code>contentSize</code>,<code>contentOffset</code>contentOffset这个属性表示当前视图左上角与content的左上角的x,y的偏移量.<code>scrollView.bounds</code>表示当前所见区域.</p>

<p>将当前可见区域转化成content所在坐标系的坐标
<code>CGRect visibleRect = [scrollView convertRect:scrollView.bounds toView:subview];</code>
在创建UIScrollView时不要忘记设置contentSize,在需要reset的时候也不要忘记reset.最好将设置contentSize的方法发在,随时要改变view大小的方法中.</p>

<pre><code>//滑至指定区域
- (void)scrollRectToVisible:(CGRect)aRect animated:(BOOL)animated;
</code></pre>

<h4>缩放(Zooming)</h4>

<p>要想缩放生效,必须<em>1.设置最小/最大缩放比例.2.实现代理方法<code>
- (UIView *)viewForZoomingInScrollView:(UIScrollView *)sender;</code></em></p>

<pre><code>//关于缩放的一些属性和方法
@property (nonatomic) float zoomScale;  !
- (void)setZoomScale:(float)scale animated:(BOOL)animated;  
- (void)zoomToRect:(CGRect)zoomRect animated:(BOOL)animated;   
- (void)scrollViewDidEndZooming:(UIScrollView *)sender      
                       withView:(UIView *)zoomView 
                        atScale:(CGFloat)scale;
</code></pre>

<h4>Demo</h4>

<p>让imageView自适应image可调用<code>[imageView sizeToFit]</code>方法。</p>

<p>如果自己复写了某属性的getter和setter方法就不要在用_someThing而是使用self.someThing.</p>

<p>prepareForSegue方法发生在oulet被设置之前.</p>

<p>NSURLSessionConfiguration有三个类构造函数，这很好地说明了NSURLSession是为不同的用例而设计的。相关介绍可以看这里<a href="http://jishu.zol.com.cn/201091.html">iOS 7系列译文：忘记NSURLConnection，拥抱NSURLSession吧！</a></p>

<pre><code>//返回标准配置，这实际上与NSURLConnection
//的网络协议栈是一样的，具有相同的共享NSHTTPCookieStorage，共享
//NSURLCache和共享NSURLCredentialStorage。
+ defaultSessionConfiguration

//返回一个预设配置，没有持久性存储的缓存，Cookie或证书。
//这对于实现像秘密浏览功能的功能来说，是很理想的。
+ ephemeralSessionConfiguration

//独特之处在于，它会创建一个后台会话。
//后台会话不同于常规的，普通的会话，它甚至可以在应用程序挂起，退出，崩溃的
//情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外
//恢复后台传输的守护进程提供上下文。
+ backgroundSessionConfiguration:(NSString *)name
</code></pre>

<p>在下载时,最好判断request.URL和imgurl是否一致.</p>

<h1><a id="10"></a>10.UITableView</h1>

<h4>TableView的种类</h4>

<ul>
<li><em>Plain or Grouped</em></li>
<li><em>Static or Dynamic</em>:静态一般用作设置之类的,动态是用来加载数据之类的</li>
<li><em>Devided into sections or not</em></li>
<li><em>Different formats for each row in the table</em></li>
</ul>


<h4>tableView的分布</h4>

<p><img src="http://wang9262.github.io/images/blogimg/stanford/header_footer.png" alt="" /></p>

<h4>Cell的样式</h4>

<ul>
<li><em>Subtitle(UITableViewCellStyleSubtitle)</em></li>
<li><em>Basic(UITableViewCellStyleDefault)</em></li>
<li><em>Right/Left Detail(UITableViewCellStyleValue1/Value2)</em></li>
</ul>


<p>一定要记得为不同的cell设置标识符(<code>identifier</code>)。</p>

<h4>两个协议UITableViewDelegate、UITableViewDataSource</h4>

<p><code>delegate</code>用来控制<code>tableview</code>如何被显示的,<code>datasource</code>为<code>cell</code>的各种显示细节提供数据。如果给一个非<code>TableviewController</code>添加<code>tableview</code>,一定要记住给这个tableview添加<code>delegate</code>和<code>datasource</code>即</p>

<pre><code>self.tableview.delegate = self;
self.tableview.dataSource = self;
</code></pre>

<p>dataSource的几个除返回row和section外的重要的方法</p>

<pre><code>//only for dynamic ones
- (UITableViewCell *)tableView:(UITableView *)sender
cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    cell = [dequeueReusableCellWithIdentifier: forIndexPath:];
}
在prepareForSegue方法中调用indexPathForCell:方法,
可以获取当前的cell  index
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender     
{      
    NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];     
//  prepare  segue.destinationController to display based on information  
//   about my Model corresponding to  indexPath.row  in  indexPath.section 
}
</code></pre>

<h1><a id="11"></a>11.Document&amp;Core Data</h1>

<p><code>NSManagedObject</code>是<code>CoreData</code>所有类的根类</p>

<p>获取<code>NSManagedObjectContext</code>,有两种方法</p>

<pre><code>1.创建UIManagedDocument,然后可以取得其属性managedObjectContext
2.创建工程时,勾选"use core data"
</code></pre>

<p>创建<code>UIManagedDocument</code></p>

<pre><code>NSFileManager *fileManager = [NSFileManager defaultManager]; 
NSURL *documentsDirectory = [[fileManager URLsForDirectory:NSDocumentDirectory 
                                            inDomains:NSUserDomainMask] firstObject]; 
NSString *documentName = @“MyDocument”; 
NSURL *url = [documentsDirectory URLByAppendingPathComponent:documentName]; 
UIManagedDocument * document = [[UIManagedDocument alloc] initWithFileURL:url]; 
</code></pre>

<p>上面代码段创建了<code>UIManagedDocument</code> 实例,但没有打开也没有生成相应文件</p>

<h4>怎么打开或者创建<code>UIManagedDocument</code> ?</h4>

<pre><code>//1.先检测UIManagedDocument 的底层文件是否存在
BOOL fileExists =  [[NSFileManager defaultManager] fileExistsAtPath:[url path]];,
//如果存在,则打开
[document openWithCompletionHandler:
^(BOOL success) { /* block to execute when open */  }];
//如果不存在,则创建,url应该用document.fileURL属性作参数
[document saveToURL:url 
   forSaveOperation:UIDocumentSaveForCreating
   competionHandler:^(BOOL success) { /* block to execute when create is done */  }];  

//下面是一段完整的代码,documentIsReady是一个自定义方法,在打
//开或创建成功后才执行的代码
self.document = [[UIManagedDocument alloc]initWithFileURL: (URL *)url];   
if ([[NSFileManager defaultManager]  fileExistsAtPath:[url path]]) {   
[document openWithCompletionHandler: ^(BOOL success) {    
    if (success) [self documentIsReady];   
    if (!success) NSLog(@“couldn’t open document at %@”, url);  
}];  
} else {  
    [document saveToURL:url forSaveOperation:UIDocumentSaveForCreating  
   completionHandler: ^(BOOL success) {    
    if (success) [self documentIsReady];   
    if (!success) NSLog(@“couldn’t create document at %@”, url);  
    }];  
}  
// can’t do anything with the document yet (do it in  documentIsReady).
//打开或创建成功后,就可使用了,最好对document的状态做个判断
- (void) documentIsReady  
{    
     if (self.document.documentState ==  UIDocumentStateNormal ) {    
         // start using document  
    }     
}
</code></pre>

<h4>ducument的状态还有下面几个</h4>

<ul>
<li>UIDocumentStateClosed</li>
<li>UIDocumentStateSavingError</li>
<li>UIDocumentStateEditingDisabled</li>
<li>UIDocumentStateInConflict

<h4>document的关闭与保存</h4></li>
<li><h5>关闭</h5>

<p>  在没有被强引用时就会自动关闭,也可以用下面方法来关闭它,它是异步的
  <code>[self.document closeWithCompletionHandler:^(BOOL success) {    
  if (!success) NSLog(@“failed to close document %@”,  self.document.localizedName); }];</code></p></li>
<li><h5>保存</h5>

<p>  document会自动保存,如果需要手动保存(也是异步的),可以使用下面方法(将会在主线程上被调用)
  <code>[document saveToURL:document.fileURL   
 forSaveOperation:UIDocumentSaveForOverwriting   
 competionHandler:^(BOOL success) { /* block to execute when save is done */  }];</code></p>

<h4>监听document的managedObjectContext</h4>

  //center为[NSNotificationCenter defaultCenter]
  //开启监听

<ul>
<li>(void)viewDidAppear:(BOOL)animated  <br/>
{  <br/>
  [super viewDidAppear:animated];    <br/>
  [center addObserver:self   <br/>
             selector:@selector(contextChanged:)
                 name:NSManagedObjectContextDidSaveNotification
               object:document.managedObjectContext];  //   不要传空值
}<br/>
//移除监听</li>
<li>(void)viewWillDisappear:(BOOL)animated   <br/>
{  <br/>
  [center removeObserver:self  <br/>
                    name:NSManagedObjectContextDidSaveNotification  <br/>
                  object:document.managedObjectContext];  <br/>
  [super viewWillDisappear:animated];  <br/>
}</li>
<li>(void)contextChanged:(NSNotification <em>)notification  <br/>
{
  //在这里处理context发生改变时需要进行的操作 <br/>
  // notification.userInfo拥有以下key(均为数组) <br/>
  //NSInsertedObjectsKey
  //NSUpdatedObjectsKey
  //NSDeletedObjectsKey
}<br/>
//在接收到通知时,可以通过调用下面方法来合并数据库的变化
//&ndash; (void)mergeChangesFromContextDidSaveNotification:(NSNotification   </em>)notification;

<h4>插入</h4>

NSManagedObjectContext <em>context = aDocument.managedObjectContext;<br/>
NSManagedObject </em>photo =<br/>
[NSEntityDescription insertNewObjectForEntityForName:@“Photo” inManagedObjectContext: context];<br/>
新插入对象的属性均为nil(除非在Xcode中指定一个默认值)

<h4>删除</h4>

<p>调用<code>[aDocument.managedObjectContext deleteObject:photo];</code> 即可.在删除该属性后,需要将指向它的强引用置nil.删除之后实体间的关系会自动更新.</p></li>
</ul>
</li>
</ul>


<p>也可以写一个分类,添加- (void)prepareForDeletion方法,在该方法中进行一些相应的操作.</p>

<h4>查询(Query)</h4>

<p>创建<code>NSFetchRequest</code>四要素</p>

<ul>
<li>想要获取的实体</li>
<li>一次性获取实体的数目(默认为全部实体)</li>
<li>用来指定返回顺序的NSSortDescriptor</li>
<li>用来指定获取哪些实体的NSPredicate</li>
</ul>


<p>创建的代码</p>

<pre><code>NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@“Photo”]; 
request.fetchBatchSize = 20; 
request.fetchLimit = 100;  
request.sortDescriptors = @[sortDescriptor]; 
request.predicate = ...;
</code></pre>

<h5>NSSortDescriptor</h5>

<p>`NSSortDescriptor *sortDescriptor =
 [NSSortDescriptor sortDescriptorWithKey:@“title”</p>

<pre><code>                           ascending:YES  
                            selector:@selector`(localizedStandardCompare :)]; 
</code></pre>

<h5>NSPredicate(谓词)</h5>

<p>明确指定我们需要从数据库得到的实例.当其为nil即意味着所有的.</p>

<pre><code>NSString *serverName = @“flickr-5”;  
NSPredicate *predicate =   
[NSPredicate predicateWithFormat:@“thumbnailURL contains %@”, serverName]; 
</code></pre>

<h5>NSCompoundPredicate(复合谓词)</h5>

<pre><code>NSArray *array = @ [predicate1, predicate2];  
NSPredicate *predicate = [NSCompoundPredicate andPredicateWithSubpredicates:array];
</code></pre>

<h5>高级查询</h5>

<ol>
<li>使用KVC(key value coding)</li>
</ol>


<p>可以使用谓词,比如<code>@“photos.@count &gt; 5”</code>,意味着所有大于5的Photographers.<code>@count</code>是database自执行的一个函数,还有一些其他类似的.</p>

<p>查看更多请点击<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueCoding/Articles/CollectionOperators.html">这里</a></p>

<h4>实例属性的获取</h4>

<pre><code>- (id)valueForKey:(NSString *)key; 
- (void)setValue:(id)value forKey:(NSString *)key;
//同样也可以用
valueForKeyPath: /setValue:forKeyPath:这两个方法会自动遵循实体之间的关系
</code></pre>

<p>同样我们可以通过Xcode来同时生成头文件(实体属性的property)和实现代码(实现代码里没有对@property进行@synthesize,需要注意)</p>

<h4>分类(Category)</h4>

<p>分类并不是子类,分类也有自己的.m和.h文件,同时它不能拥有实例变量,可以有属性变量(@property).分类中最好不要复写本类的原有方法.</p>

<h4>CoreData的线程安全</h4>

<p> <code>NSManagedObjectContext</code>是非线程安全的,通常coredata使用 <code>NSManagedObjectContext</code>非常迅速,所以多线程操作是没有必要的.</p>

<pre><code>[context performBlock:^{  // or performBlockAndWait:
// do stuff with context in its safe queue (the queue it was created on) !
}];  
</code></pre>

<h1><a id="12"></a>12. Core Data and Table View</h1>

<h4>NSFetchedResultsController</h4>

<p> <code>NSFetchedResultsController</code>和<code>NSFetchRequest</code>建立了相应联系,所以只要在<code>UITableViewDataSource</code>中使用即可(在UITableviewController中申明<code>NSFetchedResultsController</code>属性).比如</p>

<pre><code>- (NSUInteger)numberOfSectionsInTableView:(UITableView *)sender  
{  
    return [[self.fetchedResultsController sections] count];  
} 

- (NSUInteger)tableView:(UITableView *)sender numberOfRowsInSection:(NSUInteger)section  
{  
    return [[[self.fetchedResultsController sections] objectAtIndex:section] numberOfObjects];  
}  
</code></pre>

<p><code>UITableviewController</code>有一个比较常用的方法就是<code>objectAtIndexPath:</code>比如</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)sender  
     cellForRowAtIndexPath:(NSIndexPath *)indexPath  
{ 
    UITableViewCell *cell = ...; 
    NSManagedObject *managedObject =   // or, e.g.,  Photo *photo = (Photo *) … 
    [self.fetchedResultsController objectAtIndexPath:indexPath]; 
    // load up the cell based on the properties of the  managedObject !
    // of course, if you had a custom subclass, you’d be using dot notation to get them
    return cell; 
}
</code></pre>

<p>创建<code>UITableviewController</code></p>

<pre><code>NSFetchedResultsController *frc = [[NSFetchedResultsController alloc] 
initWithFetchRequest:(NSFetchRequest *)request 
managedObjectContext:(NSManagedObjectContext *)context 
  sectionNameKeyPath:(NSString *)keyThatSaysWhichSectionEachManagedObjectIsIn 
           cacheName:@“MyPhotoCache”];//cacheName可为nil,这里的cache必须为同一个NSFetchRequest下的cache
</code></pre>

<p><code>UITableviewController</code>会&#8221;监听&#8221;coredata的变化,然后自动更新列表.使用的是KVO(key-value observing)机制,当&#8221;监听&#8221;到变化,它会发送像下面的消息给它的delegate.</p>

<pre><code>- (void)controller:(NSFetchedResultsController *)controller 
didChangeObject:(id)anObject 
    atIndexPath:(NSIndexPath *)indexPath 
  forChangeType:(NSFetchedResultsChangeType)type 
   newIndexPath:(NSIndexPath *)newIndexPath 
{ 
    //这里可以调用tablevie的一些方法来更新列表
}
</code></pre>

<h1><a id="13"></a>13.其他</h1>

<blockquote><ul>
<li>关于视频:我已经打包好了,包括视频,源码,以及每节课的slides以及Assignments。下载请戳<a href="http://pan.baidu.com/s/1gdqTYPd">这里</a>
-本文将不断更新,如果发现文中的问题,请在评论中指出,谢谢。</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git学习笔记]]></title>
    <link href="http://wang9262.github.io/blog/2013/12/01/git-study/"/>
    <updated>2013-12-01T21:19:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2013/12/01/git-study</id>
    <content type="html"><![CDATA[<p>   最近学习了一下git的基本命令，这篇文章是我自己的学习笔记，一来是为了分享，二来是为了以这种方式记下来，日后忘记时可以再来看看，本文会持续更新，把我在用git时遇到的问题以及一些比较好的建议记录下来，欢迎多多交流。</p>

<!--more-->


<p>
<img src="http://wang9262.github.io/images/blogimg/git/git.png" alt="" /></p>

<ol>
<li><a href="#1">git的大致思路</a></li>
<li><a href="#2">git的各种命令</a></li>
<li><a href="#3">分支</a></li>
<li><a href="#4">tag</a></li>
<li><a href="#5">更新</a></li>
<li><a href="#6">更多</a></li>
</ol>


<h3><a id="1"></a>git的大致思路</h3>

<p>   git分三个区，一个是History（历史记录），Working Directory（工作目录）以及Stage（缓存区）也叫Index（索引）。大致结构如下图所示</p>

<p>   <img src="http://wang9262.github.io/images/blogimg/git/threearea.png" alt="" /></p>

<p>   <img src="http://wang9262.github.io/images/blogimg/git/gitmode.png" alt="" /></p>

<p>   其中History可以看做是一根时间轴，上面布满了各种commit id，这些id都是hash生成的，可以不用去管它，理解成为标识符就好，如下图所示
   <img src="http://wang9262.github.io/images/blogimg/git/timebar.png" alt="" /></p>

<h3><a id="2"></a>git的各种基本命令</h3>

<h4>2.1 add命令</h4>

<p><code>git add filename</code>就是将当前工作路径下的filename文件添加到缓存区</p>

<h4>2.2 commit命令</h4>

<p><code>git commit -m ‘some commit info’</code>将某文件添加到缓存区后，在提交到历史记录，此时git会为你生成一个相应的commit id。</p>

<h4>2.3 log以及reflog命令</h4>

<p><code>git log</code>即查看提交日志，此时只有commit的记录没有头指针移动的记录如左图所示</p>

<p><img src="http://wang9262.github.io/images/blogimg/git/gitlog.png" alt="" /></p>

<p><code>git log --pretty=oneline</code>即以单行形式显示log日志，如图所示</p>

<p><img src="http://wang9262.github.io/images/blogimg/git/onelinelog.png" alt="" /></p>

<p><code>git reflog</code>即查看所有提交日志，以及其他的一些操作，简化了commit id
<img src="http://wang9262.github.io/images/blogimg/git/reflog.png" alt="" /></p>

<h4>2.4 回到上一次commit会回到指定的commit</h4>

<p><code>git reset --hard head^</code>回到上一个commit节点，这个有点HEAD类似C语言的指针，可以指向不同的commit id。
<code>git reset --hard commit_id(两杠之后无空格)</code>回到指定的commit节点（commit_id），这里的id时git reflog之后显示的commit id 并非log里面的id。</p>

<h4>2.5 恢复某个修改的文件</h4>

<p><code>git checkout -- fliename(两杠之后有空格)</code>，如果修改了某个文件，没有将其add到缓存区，调用该命令，可以恢复到修改之前的内容，即上一次commit之后的内容，如果这个时候已经add此语句无效，需要用下一语句。</p>

<p><img src="http://wang9262.github.io/images/blogimg/git/check_noadd.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/git/check_noadd1.png" alt="" /></p>

<p><code>git reset head filename</code>和<code>git checkout -- filename</code>如果修改之后并且已经add到缓存区，则可用这两个语句来恢复到修改之前的文件。<code>git reset head filename</code>相当于取消了add，即将该文件从缓存区中删除了，有一点需要注意一下就是无论你add多少次（没有commit的前提下），仅需一次reset即可取消所有的add.下图是我自己在做试验时的截图。</p>

<p><img src="http://wang9262.github.io/images/blogimg/git/reset_add.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/git/reset_add1.png" alt="" /></p>

<h4>2.6 删除</h4>

<p><code>rm filename</code>从此盘中删除某个文件，该操作可通过<code>git checkout -- filename</code>来恢复。<code>git rm filename</code>是从git目录下删除文件，该操作是无法恢复的（不管有没有commit都不能恢复），只能通过通过头指针指向上一个commit节点（见上面2.4）来实现恢复。</p>

<p><img src="http://wang9262.github.io/images/blogimg/git/disk_rm.png" alt="" /></p>

<p><img src="http://wang9262.github.io/images/blogimg/git/git_rm.png" alt="" /></p>

<h3><a id="3"></a>分支（Branch）</h3>

<p>分支在git中扮演着重要的角色，尤其是对于分布式的相互协作。下面看一些常用的branch分支命令</p>

<blockquote><ul>
<li><code>git remote add origin git_address</code>为本地git添加远程服务器。</li>
<li><code>git push -u origin(远程默认主分支) master(本地默认主分支)</code>第一次push加上<code>-u</code>指令，在以后的push中就可以直接push就行了</li>
<li><code>git branch</code>查看当前所处分支（带星号代表当前分支）</li>
<li><code>git branch branchname</code>创建新的分支</li>
<li><code>git check branchname</code>分支之间的切换</li>
<li><code>git checkout -b branchname</code>创建分支并直接切换到刚创建的分支，相当于上面两个命令的合并。</li>
</ul>
</blockquote>

<p>在一个分支里面（非主分支）里面新建、修改文件，只要没有add,commit操作，切回主分支的时候是可以看到刚刚新建、修改的文件，一旦add，commit之后在主分支是不可见的</p>

<h4>3.1 Merge（合并分支）命令</h4>

<blockquote><ul>
<li><code>git merge branchname</code>如果在主分支（master）下执行该命令，则直接合并master和branchname，master的头指针指向branchname的头指针（该操作并没有保存branchname，此时branchname和master相当于同一个分支）</li>
<li><code>git merge --no-ff -m 'merge information ' branchname</code>如果在主分支（master）下执行该命令则保存dev且将dev和master合并，可以理解为相当于在master里面复制了一份dev(推荐这种操作)</li>
</ul>
</blockquote>

<h4>3.2 删除分支</h4>

<blockquote><ul>
<li><code>git branch -d branchname</code>删除某个分支，无法恢复</li>
<li><code>git branch -D branchname</code>强制删除</li>
</ul>
</blockquote>

<h3><a id="4"></a>tag</h3>

<blockquote><ul>
<li><code>git tag tagname</code>创建tag</li>
<li><code>git check tag</code>检查当前所有tag</li>
<li><code>git push --tags</code>向远程提交tag</li>
<li><code>git tag -d tagname</code>删除本地tag</li>
<li><code>git push origin :refs/tags/tagname</code>删除远程tag</li>
</ul>
</blockquote>

<h3><a id="5"></a>更新</h3>

<h5>12月9号更新</h5>

<hr />

<h6>1.关于add和commit命令的合并</h6>

<p>可用命令<code>git commit -am 'commit info'</code>但是该命令只能对已经存在的文件执行，若有新增文件，则git会报错。</p>

<h6><a id="modify"></a>2.合并的问题</h6>

<p>如果在某个分支上修改了某文件，然后add->commit，再回到主分支对同一文件进行修改，在add->commit，此时若进行合并，则会报错说修改有冲突，如果此时查看冲突，则可以看见如图所示的东西(Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，>>>>>>>标记出不同分支的内容)。</p>

<p><img src="http://wang9262.github.io/images/blogimg/git/merge_modify.png" alt="" /></p>

<p>所以应该手动来修改,冲突修改好后，add->commit即可。修改完成后，history大致如图所示,也可以用<code>git log --graph --pretty=oneline --abbrev-commit</code>来产看合并之后的图表</p>

<p><img src="http://wang9262.github.io/images/blogimg/git/merge_pic.png" alt="" /></p>

<h6>3.重开分支</h6>

<p>假设现在在dev分支上将代码已经进行到一半了，突然想起有个很明显的bug，但是又不想放弃当前的代码修改，这时可以在当前分支用git stash命令来将当前工作现场隐藏起来，然后在主分支（或其他非dev分支）上新建分支来修复bug，修复完后合并到主分支，再转到dev分支
可以通过以下两种方法来恢复之前隐藏的内容</p>

<p><code>git stash apply</code>  恢复后，并没有删除stash隐藏的内容</p>

<p><code>git stash pop</code>  恢复并删除stash隐藏的内容</p>

<h6>4.远程推送</h6>

<p>向远程端push分支，<code>git push origin branchname</code></p>

<p>查看远程库信息 <code>git remote -v</code>
<code>git checkout -b branchname origin/branchname</code> 在本地创建一个与远程分支名字一致的分支，然后可以修改分支内容然后向远程push.
当远程库与本地库有冲突的时候，（即在不同的电脑上向远程库提交代码），需要先把远程库pull 下来，但是仅仅git pull是不够的
因为没有指定本地分支与远程分支的链接。</p>

<p>需要先执行<code>git branch --set-upstream branchname origin/branchname</code>,然后再执行git pull命令即可。如果此时有文件修改冲突，解决该冲突后在add commit 即可。此时再push到远程即可。这个和前面  <strong><em><a href="#modify">2.合并的问题</a></em></strong>  思路一致</p>

<h6>5.git的个性化</h6>

<p><code>git config --global color.ui true</code> // 显示颜色</p>

<p><code>git config --global alias.st status</code> // 为status设置别名,也可以为其他命令设置别名 <code>git config --global alias.othername commandname</code></p>

<p>也可以给一连串的命令设置别名.比如：<code>git config --global alias.unstage 'reset HEAD'</code>.</p>

<p>更多的个性化可参考<a href="http://git-scm.com/book/zh/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git">7.1 自定义 Git &ndash; 配置 Git</a></p>

<h3><a id="6"></a>更多</h3>

<h5>各种dos/linux命令的解释</h5>

<hr />

<p><code>ls</code>查看当前路径下的文件（无隐藏文件）</p>

<p><code>ls -a</code>查看当前路径下所有的文件（含隐藏文件）</p>

<p><code>vi filename</code>用vim修改（或新建）文件（文件需带后缀，下同），进入vim后按下i键进入编辑模式，编辑完成按下esc，再输入<code>：wq</code>即可退出编辑模式</p>

<p><code>cat filename</code>显示文件内容</p>

<p><code>cat &gt;filename</code>只能创建新文件，不能编辑其内容</p>

<p><code>cd ..</code>返回上级目录，<code>cd .</code>当前目录,<code>cd /</code>回到根目录</p>

<p><code>pwd</code>查看当前目录的完整路径</p>

<h5>参考资料：</h5>

<blockquote><ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">rogerdudler</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">斯坦福大学</a></li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html#checkout">marklodato</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰</a></li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[oc内存管理学习]]></title>
    <link href="http://wang9262.github.io/blog/2013/11/10/memory-manage/"/>
    <updated>2013-11-10T15:34:00+08:00</updated>
    <id>http://wang9262.github.io/blog/2013/11/10/memory-manage</id>
    <content type="html"><![CDATA[<p>   本文是自己对内存管理方面的一些见解，由于接触oc时间不长，基础也不怎么牢靠，做起项目来也不能得心应手。于是就好好得看了别人的博客以及自己将不能理解的地方做了demo来解决自己以前一直有疑虑的地方。本文会持续更新，列出自己在学习过程中遇到的内存管理问题。</p>

<!--more-->


<h2>1.深浅拷贝</h2>

<p>   首先是讲一讲深浅拷贝的问题，先看下表
   <img class="left" src="http://wang9262.github.io/images/blogimg/copytable.png" width="409" height="140" title="image" alt="images"></p>

<p>   从表中可以看出，对于任何对象(实现了NSCopying协议)调用copy方法（无论是可变还是不可变对象），将会返回不可变对象，调用mutableCopy将会返回可变对象，且产生新的对象，源对象引用计数不变。
(实现NSCopying协议的- (id)copyWithZone:(NSZone *)zone 方法即可调用copy及mutableCopy)</p>

<p>对不可变的对象调用copy方法(浅拷贝)，这时仅仅为指针拷贝，不会产生新的对象，源对象的引用计数将会加1，此时相当于retain。若此时改变了源对象的内容将不会影响到copy之后得到的对象的内容。如下例</p>

<pre><code>NSString *string = [[NSString alloc] initWithFormat:@"age is %i", 10];
NSLog(@"%zi", [string retainCount]);   //1
NSString *str = [string copy];

// string:0x10010bd80,str:0x10010bd80指针地址一致
NSLog(@"string:%p,str:%p",string,str);
NSLog(@"string:%zi", [string retainCount]);//2
NSLog(@"str:%zi", [str retainCount]);//2

//改变string的内容，此时没有alloc等操作，所以内存是不需自己管理
string = @"xyz";

//理论上为0，但是打印出来是-1，这个问题stackoverflow上面说
//对一个引用计数为零的对象调用retainCount方法是不会得到正确的 
//结果的。
NSLog(@"string:%zi", [string retainCount]);   

//string:0x1000025f0,str:0x10010bd80此时string的指针地
//址发生改变，而str保持原来的指针原因是string指向的内容发生了
//改变,即使此时将其内容改为和原来一样，即(string = @"age is 
//10"),其指针还是发生了相应的变化，而不是保持为原来的。
NSLog(@"string:%p,str:%p",string,str);

//此时str的引用计数仍为2
NSLog(@"str:%zi", [str retainCount]);

//打印的结果：xyz,age is 10       
NSLog(@"%@,%@",string,str);
[str release];
NSLog(@"str:%zi", [str retainCount]);//1
[str release];

//理论上为0，打印为随机数，理由同上
NSLog(@"str:%zi", [str retainCount]);
</code></pre>

<p>由于水平有限，如果发现本文有问题，可以在评论中指出，谢谢！</p>
]]></content>
  </entry>
  
</feed>
